---
title: "1015. Smallest Integer Divisible by K"
problemId: 1015
difficulty: Medium
source: LeetCode
topics: Math, Modulo
---

# 1015. Smallest Integer Divisible by K

## 題目描述（中文重點）

給定一個正整數 `k`，我們要找到最短的正整數 `n`，滿足：

1. `n` 只由數字 `1` 組成（例如：1, 11, 111, 1111, ...）。
2. `n` 可以被 `k` 整除。

回傳這個 `n` 的「位數長度」。  
如果不存在這樣的 `n`，則回傳 `-1`。

> 題目特別提醒：`n` 可能大到放不進 64-bit integer，所以不能真的把 `n` 建出來。

---

## 解題觀念整理

### 1. 暴力直覺想法（不行的做法）

直覺可能會想這樣做：

- 從 `n = 1, 11, 111, 1111, ...` 一直往上試：
  - 每次檢查 `n % k == 0` 就回傳長度。

但問題是：

- `n` 只會越來越長，位數會很快超過 `long long` 的範圍。
- 題目也明確提示：「`n` 可能放不進 64-bit」。

因此不能直接把 `n` 當整數來存，只能「用模運算」來處理。

---

### 2. 只維護「餘數」就好

假設我們現在有某個只由 1 組成的數字 `x`，  
它對 `k` 的餘數是：

\[
r = x \bmod k
\]

下一個數字 `x'` 是：

\[
x' = x \cdot 10 + 1
\]

則它對 `k` 的餘數是：

\[
x' \bmod k = (x \cdot 10 + 1) \bmod k = (r \cdot 10 + 1) \bmod k
\]

也就是說：

> 我們不需要知道真正的 `x` 是多少，只要知道「目前餘數 r」，  
> 下一步的餘數就可以用 `r = (r * 10 + 1) % k` 來更新。

因此可以這樣做：

1. 一開始用 `r = 1 % k`（對應數字 `1`）。
2. 檢查如果 `r == 0`，代表 `1` 就可以被整除，長度為 1。
3. 否則每次更新：
   ```cpp
   r = (r * 10 + 1) % k;
   ```
   每更新一次，長度就多 1。
4. 一旦某次 `r == 0`，就回傳目前長度。

---

### 3. 鴿籠原理：為什麼迴圈只需要跑到 k 次？

關鍵：**餘數的可能值只有 k 種**：

- 餘數只可能是 `0, 1, 2, ..., k - 1`，總共 k 種。

我們從 `1` 開始，不斷更新：

```cpp
r = (r * 10 + 1) % k;
```

假設我們一直沒有碰到 `r == 0`，那麼「非零餘數」的狀態就會一直變換。

- 最多只能有 `(k - 1)` 種非零餘數。
- 如果我們走了 `k` 步都沒有出現 `0`，  
  代表在這 `k` 個狀態當中，至少有兩次餘數是一樣的（鴿籠原理）。

一旦餘數重複，後面就會開始 **循環**，而既然循環裡不存在 `0`，  
就代表不可能再有某個長度讓餘數變成 0。

所以可以得出結論：

> 最多只需要檢查 **k 次** 長度就夠了。  
> 如果前 k 次內沒有出現 `r == 0`，直接回傳 `-1`。

這就是為什麼我們的迴圈寫成：

```cpp
for (int len = 1; len <= k; ++len) { ... }
```

而不是無限制增加長度。

---

### 4. 特殊剪枝：遇到 2 或 5 直接回傳 -1

任何只由 `1` 組成的整數：

- 尾數永遠是 `1`。
- 因此不可能被 `2` 整除（奇數）。
- 也不可能被 `5` 整除（尾數不是 0 或 5）。

所以如果 `k` 含有因數 `2` 或 `5`，就不可能有答案：

```cpp
if (k % 2 == 0 || k % 5 == 0) {
    return -1;
}
```

這個檢查可以在一開始就做掉一些不可能的 case。

---

## C++ 解法程式碼

這份是你最後得到的乾淨寫法，可以直接提交 LeetCode：

```cpp
class Solution {
public:
    int smallestRepunitDivByK(int k) {
        // 若含有因數 2 或 5，不可能被全為 1 的數整除
        if (k % 2 == 0 || k % 5 == 0) {
            return -1;
        }

        int r = 1 % k;  // 對應數字 1 的餘數
        for (int len = 1; len <= k; ++len) {
            if (r == 0) {
                return len; // 長度為 len 的全 1 數可整除 k
            }
            // 下一個數字：在末尾多接一個 '1'
            r = (r * 10 + 1) % k;
        }
        return -1; // 超過 k 長度仍沒出現 r == 0，代表不可能
    }
};
```

若你想保留你原本比較精簡的版本（沒有剪枝），也可以是：

```cpp
class Solution {
public:
    int smallestRepunitDivByK(int k) {
        int r = 1 % k;
        for (int len = 1; len <= k; ++len) {
            if (r == 0) return len;
            r = (r * 10 + 1) % k;
        }
        return -1;
    }
};
```

---

## 複雜度分析

- 迴圈最多跑 `k` 次，每次都是 O(1) 的運算：
  - 模運算、乘法、加法。
- **時間複雜度**：\(O(k)\)
- **空間複雜度**：\(O(1)\)

在題目限制 `1 <= k <= 10^5` 下，`O(k)` 是可接受的。

---

## 個人筆記 / 小反思

- 一開始卡住的點是「不知道迴圈長度要設多少」，  
  後來想到用 **鴿籠原理** 去推「最多只需要試到長度 = k」就非常關鍵。
- 這題也是典型的「**不能存整個數，只能存模數（餘數）**」的題目，  
  跟很多「大數 / 重複 pattern」的問題都有共通技巧：
  - 不關心數字本身，只關心它對某個值的餘數。
- 記住這個基本 pattern 之後，  
  之後看到「重複字元構成的大數 + 取模 / 可被整除」之類的題目，  
  大多數都可以直接往「維護餘數 + 鴿籠原理 / 餘數循環」這條路想。
