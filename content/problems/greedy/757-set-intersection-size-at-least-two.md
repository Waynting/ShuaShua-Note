---
title: "757. Set Intersection Size At Least Two"
problemId: 757
difficulty: Hard
source: LeetCode
topics: Greedy, Interval, Sorting
---

# 757. Set Intersection Size At Least Two

## 題目敘述（中文整理）

給定一個 2D 整數陣列 `intervals`，其中：  

- `intervals[i] = [start_i, end_i]`  
- 表示這個區間包含所有從 `start_i` 到 `end_i` 的整數（**閉區間**）。  

我們定義一個「**containing set**」為一個整數陣列 `nums`，若它滿足：  

> 對於 `intervals` 裡的每一個區間 `[start_i, end_i]`，  
> 在 `nums` 裡面，**至少有兩個整數** 也落在這個區間裡。  

換句話說：  
- 對每個區間 `[start_i, end_i]`，  
- `| { x ∈ nums | start_i ≤ x ≤ end_i } | ≥ 2`。  

要求：  
> 回傳一個 **最小可能大小** 的 containing set 的大小（不需要回傳實際陣列）。  

---

### 範例簡述

#### Example 1

```text
intervals = [[1,3],[3,7],[8,9]]
Output = 5
```

一個合法的 `nums` 可以是： `[2,3,4,8,9]`  

- 對 `[1,3]`：交集是 `{2,3}` → 至少 2 個 ✅  
- 對 `[3,7]`：交集是 `{3,4}` → 至少 2 個 ✅  
- 對 `[8,9]`：交集是 `{8,9}` → 至少 2 個 ✅  

證明可以 show 出來：不可能用少於 5 個數字達成。  

#### Example 2

```text
intervals = [[1,3],[1,4],[2,5],[3,5]]
Output = 3
```

一個合法的 `nums` 可以是： `[2,3,4]`。  

#### Example 3

```text
intervals = [[1,2],[2,3],[2,4],[4,5]]
Output = 5
```

一個合法的 `nums` 可以是： `[1,2,3,4,5]`，且無法用 4 個數字就覆蓋所有區間。  

---

## 解題核心觀念（中文口語版）

### 1. 目標：每個區間至少有兩個被選的點

我們要選一些整數，形成一個集合 `nums`，讓：  
- 每個 `[start_i, end_i]` 內至少有兩個整數來自 `nums`。  
- 而且要求 `nums` 的大小盡量小。  

**關鍵直覺**：  
> 「點要盡量選在區間的**右邊**」，  
> 這樣能被「後面的區間」重複使用，才有機會讓總點數最小。  

---

### 2. 排序策略：右端點升序、右端相同時左端點降序

我們先對所有區間排序，排序規則是：  

1. 先依照右端點 `end` 從小到大排。  
2. 若右端點相同，左端點 `start` 較大的排在前面。  

對應到程式比較函式：

```cpp
bool comp(vector<int> &a, vector<int> &b) {
    if (a[1] != b[1]) return a[1] < b[1]; // end 小的在前
    return a[0] > b[0];                   // end 相同時，start 大的在前
}
```

這樣做是為了避免：  
- 一個區間完全被另一個包含時（例如 `[1,5]` 包住 `[3,5]`），  
- 把「短、靠右的」區間先處理，能更精準地在右端放點，避免浪費。  

---

### 3. 維護「目前最大、次大的點」：a, b

我們不需要真的存整個 `nums`，只要維護：  

- `a`：目前已選點中 **第二大的值**  
- `b`：目前已選點中 **最大的一個值**  

並維護 `ans`：代表目前總共選了幾個點。  

初始化：

```cpp
int a, b = INT_MIN;
int ans = 0;
```

（`a` 之後會在第一次需要時被賦值，`b` 先設成極小）

---

### 4. 掃過排序後的每一個區間 [L, R] 的判斷邏輯

對於每個排序後的區間 `[L, R]`，依序處理：

#### 情況一：`b < L`

代表：  
> 目前所有已選點的「最大值」 `b`，都比 `L` 小，  
> 即 `{a, b}` 這兩個點 **都不在** 區間 `[L, R]` 裡。  

也就是說：這個區間「目前完全沒被覆蓋到」→ 還欠 **兩個點**。  

最好的做法：在這個區間的最右邊選兩個點： `R-1` 和 `R`。

```cpp
if (b < L) {
    a = R - 1;
    b = R;
    ans += 2;
}
```

為什麼選 `R-1` 和 `R`？  
> 因為這是「最右邊兩個點」，最有機會被後面區間重複利用。  

---

#### 情況二：`b >= L` 但 `a < L`（也就是 `a < L <= b`）

這種情況表示：  

- `b` 在 `[L, R]` 內（因為排序後 `b` 不會大於現在的 `R`）。  
- `a` 不在這個區間內。  

所以目前這個區間 **只被一個點（b）覆蓋**，還缺一個點。  

最省的做法：在這個區間最右端再補一個 `R`：

```cpp
else if (a < L) {
    a = b;      // 原本最大點退位成第二大
    b = R;      // 新選的 R 成為最新最大
    ans += 1;
}
```

如此一來， `[L, R]` 會有 `{b, R}` 兩個點，而這個新的 `R` 又盡可能靠右，可以幫助未來的區間。  

---

#### 情況三：`a >= L`（代表 a 和 b 都在區間內）

- 此時 `a` 和 `b` 兩個點都在 `[L, R]` 中。  
- 代表這個區間已經有至少兩個點覆蓋，不需要再新增點。  

程式中不用特別寫 `else` 處理，跳過這個區間即可。  

---

## 完整程式骨架（你寫的版本整理）

```cpp
bool comp(vector<int> &a, vector<int> &b) {
    if (a[1] != b[1]) return a[1] < b[1]; // end 小的先
    return a[0] > b[0];                   // end 相同時，start 大的先
}

class Solution {
public:
    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), comp);
        
        int a, b = INT_MIN; // a: second largest, b: largest
        int ans = 0;        // 已選點的總數
        
        for (auto interval : intervals) {
            int L = interval[0];
            int R = interval[1];
            
            if (b < L) {
                // 目前兩個點都不在 [L, R] 裡 → 要補兩個新點：R-1, R
                a = R - 1;
                b = R;
                ans += 2;
            } else if (a < L) {
                // 目前只有 b 在 [L, R] 裡 → 再補一個新點 R
                a = b;
                b = R;
                ans += 1;
            }
            // 否則：a >= L → a, b 都在區間內，不用補點
        }
        
        return ans;
    }
};
```

---

## 自己的口語總結（方便考前翻閱）

> 這題的關鍵是：  
> 1. **先把區間照右端點從小到大排，右端相同時左端大的放前面。**  
> 2. 只維護「目前選到的最大點 b 和第二大點 a」。  
> 3. 對每個區間 [L, R]：  
>    - 如果 `b < L` → 這個區間一個點都沒覆蓋到 → 在最右邊補 `R-1, R`，`ans += 2`。  
>    - 否則如果 `a < L` → 目前只有一個點在區間內（b 在、a 不在）→ 補 `R` 一個點，`ans += 1`。  
>    - 否則 `a >= L` → a, b 都在區間內 → 已經至少兩個點，不用再補。  
> 4. 點永遠盡量往右邊放，才可以給越多後面的區間共用。  

這份解法是這題經典的 Greedy 答案，建議你直接收進「區間＋貪心」模版。  
之後遇到「每個區間要至少 K 個點」的變形題，也可以用這個思路往下推廣。  
