---
title: "1262. Greatest Sum Divisible by Three"
problemId: 1262
difficulty: Medium
source: LeetCode
topics: Array, Dynamic Programming, Modulo
---

# 1262. Greatest Sum Divisible by Three

## Problem Description

給定一個整數陣列 `nums`，你可以從中選出任意個元素（也可以一個都不選），
目標是讓「選出的元素總和」**可以被 3 整除**，且這個總和要 **盡可能大**。  
回傳這個最大總和。

- 1 <= nums.length <= 4 * 10^4  
- 1 <= nums[i] <= 10^4  

---

## Solutions

### Solution 1: DP on (sum % 3)

#### 核心想法（中文）

因為我們只在意「總和能不能被 3 整除」，
所以不需要記錄「所有可能的總和」，只要記錄：  
> 對於「餘數 r = 0, 1, 2」，目前能達到的 **最大總和** 是多少？

定義一個長度為 3 的陣列 `dp`：

- `dp[0]`：目前能湊出、**總和 % 3 == 0** 的最大總和
- `dp[1]`：目前能湊出、**總和 % 3 == 1** 的最大總和
- `dp[2]`：目前能湊出、**總和 % 3 == 2** 的最大總和

初始化：

- 一開始什麼都不選，總和 = 0，`0 % 3 == 0` ⇒ `dp[0] = 0`
- 其他餘數暫時「不可達」，用 -1 表示：`dp[1] = dp[2] = -1`

對每一個新數字 `x`，考慮兩種選項：

1. 不選它：原來的 `dp` 狀態都保留。
2. 選它：對於每個目前可達的餘數 `r`（`dp[r] != -1`），
   - 新的總和 = `dp[r] + x`
   - 新的餘數 `nr = (r + x) % 3`
   - 用這個新的總和來更新 `dp[nr]` 的最大值。

實作時要小心：

- 不能直接在 `dp` 上原地更新，否則同一輪會「吃到剛更新的值」，產生錯誤。
- 做法：每一輪先複製一份 `new_dp = dp`，
  再用舊的 `dp` 來更新 `new_dp`，最後 `dp = new_dp`。

你原本的筆記：

> 概念是每碰到一個新的數字，就確認每個餘數的 bucket 加上他後的餘數會變多少，然後去跟原先狀態的數值比，取大值更新。

這句話其實就是在描述上面的轉移：  
-「每個餘數的 bucket」 = `dp[0]`, `dp[1]`, `dp[2]`  
-「加上他後的餘數」 = `(r + x) % 3`  
-「跟原先狀態比、取大值」 = `new_dp[nr] = max(new_dp[nr], dp[r] + x)`

最後答案就是 `dp[0]`：  
因為它代表「總和 % 3 == 0 時，最大的總和」。

---

#### 複雜度分析

- 時間複雜度：
  - 每個元素只處理一次，且每次只更新餘數 0,1,2 三種狀態
  - ⇒ **O(n)**，其中 `n = nums.length`
- 空間複雜度：
  - `dp` 與 `new_dp` 都是大小固定為 3 的陣列
  - ⇒ **O(1)** 額外空間

---

#### Code (C++17)

```cpp
class Solution {
public:
    int maxSumDivThree(vector<int>& nums) {
        int n = nums.size();
        // dp[r] = 目前能湊出「總和 % 3 == r」的最大總和，-1 代表不可達
        vector<int> dp(3, -1);
        dp[0] = 0;  // 還沒選任何數時，和為 0，餘數是 0

        for (int i = 0; i < n; ++i) {
            int x = nums[i];
            // 複製一份，避免本輪更新時使用到已更新的值
            vector<int> new_dp(dp);
            for (int r = 0; r < 3; ++r) {
                if (dp[r] != -1) {             // 這個餘數目前可達
                    int nr = (r + x) % 3;      // 新的餘數
                    new_dp[nr] = max(new_dp[nr], dp[r] + x);
                }
            }
            dp.swap(new_dp);
        }

        // dp[0] 是總和 % 3 == 0 的最大總和
        return max(0, dp[0]);
    }
};
```

---

## Personal Notes（個人筆記）

- 這題看起來像是「子序列選取 + 整除條件」，暴力列舉所有子集會是 2^n，完全不可行。
- 關鍵 insight 是：我們只 care 「總和 % 3」，所以 state 只需要 3 個，這就是一種 **壓縮 DP** 的典型例子。
- 一開始我可能會想到把所有數依 `num % 3` 分 bucket，做貪心（刪掉最小的幾個），那也是常見解法；但 DP 版本更泛用，也很適合熟悉「mod DP」。
- Bug 容易出在：  
  1. `dp` 初始化錯誤（忘記 `dp[0] = 0`、其他要設為 -1）  
  2. 同一輪迴圈裡直接改 `dp`，而不是用 `new_dp` 暫存  
- 把這題想成：「三個 bucket（余 0/1/2），每來一個新的數字，就試試看放進每個 bucket 會變成什麼餘數、總和是多少，然後只留下每個餘數的那個 **最大總和**」就很好記。

