---
title: "2435. Paths in Matrix Whose Sum Is Divisible by K"
problemId: 2435
difficulty: Hard
source: LeetCode
topics: Dynamic Programming, Matrix
---

# 2435. Paths in Matrix Whose Sum Is Divisible by K

## 題目敘述（中文重點）

給定一個 `m x n` 的非負整數矩陣 `grid`，以及一個整數 `k`。  

你從左上角 `(0, 0)` 出發，只能 **向右** 或 **向下** 移動，目標是走到右下角 `(m - 1, n - 1)`。

定義一條路徑的「路徑和」為路上所有格子數值的總和。題目要你計算：

> 有多少條路徑，使得「路徑和」可以被 `k` 整除（也就是 `sum % k == 0`）。

由於答案可能非常大，需回傳對 `1e9 + 7` 取模後的結果。

條件限制（摘要）：

- `1 <= m, n`
- `m * n <= 5 * 10^4`
- `0 <= grid[i][j] <= 100`
- `1 <= k <= 50`

---

## 解題直覺與觀念

這題本質上是一個 **「計數型 DP」**：

- 我們不是要最短路徑、最大和，而是要「**有多少種走法**」。
- 同時又有一個條件：「路徑和 % k == 0」。

**關鍵想法**：  
與其記錄「路徑和的真實值」，我們只需要記錄「路徑和對 k 的餘數」，因為：

- 兩條路徑的總和如果對 `k` 的餘數相同，它們之後在加數字、取模的行為是一樣的。
- `k <= 50`，所以餘數只會是 0 ~ k-1，狀態數量是可接受的。

因此可以用一個三維 DP：

> `dp[i][j][r]` = 從 `(0,0)` 走到 `(i-1, j-1)` 的所有路徑中，  
> 路徑和 **mod k = r** 的路徑數量。

（注意實作時我是用 1-based 的 `i, j`，對應到 `grid[i-1][j-1]`。）

---

## DP 狀態定義

令 `mod = 1e9 + 7`。  
我們建立三維陣列：

```cpp
dp[i][j][r]
```

意義為：

- 走到格子 `(i-1, j-1)`（對應原始 `grid[i-1][j-1]`）時，
- 所有可能路徑中，路徑總和對 `k` 取模等於 `r` 的「走法數量」。

> 註：為了邊界好處理，程式採用 `dp` 大小為 `(m+1) x (n+1) x k`，索引從 1 開始。  
> 即 grid 的 `(row, col)` 對應到 dp 的 `(row+1, col+1)`。

---

## 初始條件

一開始在左上角 `(0,0)`，路徑只包含這一格 `grid[0][0]`。  

令 `v0 = grid[0][0] % k`，表示這格本身的模數。

所以：

- `dp[1][1][v0] = 1`  
- 其他 `dp[1][1][r]`（`r != v0`）都是 0。

---

## 狀態轉移

從 `(i-1, j-1)` 這一格來看，它的數值為：

```cpp
value = grid[i-1][j-1] % k;
```

假設我們想知道 `dp[i][j][r]`：  
也就是走到 `(i-1, j-1)`，路徑總和 mod k = `r` 的走法數量。

來自哪裡？  
只能從「上面 `(i-1, j)`」或「左邊 `(i, j-1)`」走過來：

- 上面：`dp[i-1][j][prevMod]`
- 左邊：`dp[i][j-1][prevMod]`

其中 `prevMod` = 前一格的路徑和模數。  
當我們走到 `(i-1, j-1)` 這格時，新的模數 `r` 應該滿足：

\[
(prevMod + value) \bmod k = r
\]

因此有：

\[
prevMod \equiv r - value \pmod{k}
\]

在程式中，我們可以寫成：

```cpp
prevMod = (r - value + k) % k;
```

這樣就保證 `prevMod` 落在 `0 ~ k-1`。

所以對每個 `r`，轉移就是：

\[
dp[i][j][r] = dp[i-1][j][prevMod] + dp[i][j-1][prevMod] \pmod{mod}
\]

整體流程：

1. 外層跑所有 `i = 1..m`
2. 中間跑所有 `j = 1..n`
3. 內層跑所有 `r = 0..k-1`
4. 對當前格子 `(i-1,j-1)`，先算 `value = grid[i-1][j-1] % k`
5. 對每個目標餘數 `r`：
   - 算出 `prevMod = (r - value + k) % k`
   - 用上方 + 左方的 `prevMod` 累加進 `dp[i][j][r]`

---

## 最終答案

右下角是 `(m-1, n-1)`，對應 `dp[m][n][*]`。  

題目要的是 **路徑和可以被 `k` 整除**，也就是「模數為 0」的走法數量：

> 最終答案 = `dp[m][n][0]`

---

## C++ 實作程式碼

下面是你現在的實作，已經是標準做法，僅加上一點註解：

```cpp
class Solution {
public:
    int numberOfPaths(vector<vector<int>>& grid, int k) {
        int m = grid.size();
        int n = grid[0].size();
        int mod = 1000000007;

        // dp[i][j][r]：
        // 走到 (i-1, j-1) 時，路徑和 mod k = r 的路徑數量
        // 使用 1-based index，方便處理邊界
        auto dp = vector(m + 1, vector(n + 1, vector<long long>(k)));

        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (i == 1 && j == 1) {
                    // 起點：只有一條路徑，和就是 grid[0][0]
                    dp[i][j][grid[0][0] % k] = 1;
                    continue;
                }

                int value = grid[i - 1][j - 1] % k;

                // 對每一個目標餘數 r，從上方與左方的 prevMod 轉移過來
                for (int r = 0; r < k; ++r) {
                    int prevMod = (r - value + k) % k;
                    dp[i][j][r] = (dp[i - 1][j][prevMod] + dp[i][j - 1][prevMod]) % mod;
                }
            }
        }
        return dp[m][n][0];
    }
};
```

---

## 複雜度分析

設：

- `M = m`、`N = n`、`K = k`。
- 題目保證 `M * N <= 5 * 10^4`，`K <= 50`。

時間複雜度：

- 三重迴圈：
  - `i`：1..M
  - `j`：1..N
  - `r`：0..K-1
- 總共約 `O(M * N * K)`  
  在最壞情況下約 `5 * 10^4 * 50 = 2.5 * 10^6` 次運算，可接受。

空間複雜度：

- `dp` 的大小為 `(M+1) * (N+1) * K`，約 `O(M * N * K)`，  
  在限制範圍內也可以接受。

---

## 個人筆記 / 小反思

- 這題的關鍵是 **「把條件 sum % k == 某值，直接變成 DP 狀態的一維」**：
  - 不記實際總和，只記「模數」。
  - 典型套路：`狀態加一維：餘數 / 取模值 / 餘數類別`。
- 轉移時：「我要的是現在的 r」，  
  不是看「上一格的 r」，而是從數學關係推回去 `prevMod`：
  - `(prevMod + value) % k = r`
  - `prevMod = (r - value + k) % k`
- 實作上，逐格從左上到右下跑，先用「上層與左側」的狀態更新到當前格，  
  也符合一般走 grid DP 的直覺順序。
- 類似的題目可以套用同樣觀念：
  - 路徑和、子陣列和、子序列和，若只關心「mod 某個數」而不是「真實值」，  
    很常可以把「餘數」當成 DP 的一維來做計數或判斷。