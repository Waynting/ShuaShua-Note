---
title: "518. Coin Change II"
problemId: 518
difficulty: Medium
source: LeetCode
topics: Dynamic Programming, Array
---

# 518. Coin Change II

## 題目敘述（中文整理）

給定：  
- 一個整數 `amount` 代表目標金額。  
- 一個整數陣列 `coins`，代表各種不同面額的硬幣。每種硬幣可以使用「無限多枚」。  

請回傳：  
- **共有幾種「組合」方式**可以湊出剛好等於 `amount` 的金額。  
- 若無法湊出，回傳 `0`。  

注意：  
- 這裡的「組合」不在乎順序，只在乎「用了哪些面額，各幾枚」。  
  - 例如 `2 + 2 + 1` 和 `2 + 1 + 2` 算 **同一種**。  
- 題目保證答案可放在 32-bit signed integer 中。  

範例：

- `amount = 5, coins = [1,2,5]` → 回傳 4  
  - 5 = 5  
  - 5 = 2 + 2 + 1  
  - 5 = 2 + 1 + 1 + 1  
  - 5 = 1 + 1 + 1 + 1 + 1  

---

## 解題核心觀念

### 1. 組合 vs 排列

- **只在乎每種硬幣用了幾枚**，不在乎排列順序。  
- 典型「完全背包」＋「方案數」問題。  
- 很適合用 DP：把「金額」拆成很多子問題。  

關鍵思路：  
> 對於某一種硬幣 coin，對每個金額 j：  
> - 不用這種硬幣 → 繼承「不用它」時的方案數。  
> - 可以用這種硬幣 → 可以把 j 拆成「先拿一枚 coin」＋「剩下 j - coin 的湊法」。  

---

## 解法一：二維 DP（狀態明確版）

### 狀態定義

令 `n = coins.size()`。定義：  

> `dp[i][j]` = **只用前 `i` 種硬幣，湊出金額 `j` 的方案數**。  

- `i` 的範圍：`0 ... n`（使用 0 種、1 種、...、n 種）  
- `j` 的範圍：`0 ... amount`  

### 初始條件（base case）

- `dp[0][0] = 1`  
  - 用 0 種硬幣湊出金額 0 → 「什麼都不拿」只有 1 種方式。  
- `dp[0][j>0] = 0`  
  - 沒有硬幣，但金額 > 0 → 不可能湊出來。

### 狀態轉移

考慮第 `i` 種硬幣，面額 `coin = coins[i-1]`：  

對每個金額 `j`：

1. **不用第 i 種硬幣**  
   - 方案數 = 只用前 `i-1` 種硬幣的方案數：  
   - `dp[i-1][j]`

2. **至少用一枚第 i 種硬幣**  
   - 先拿一枚 `coin` 之後，剩下 `j - coin` 的金額，要用「前 i 種硬幣」去湊：  
   - `dp[i][j - coin]`（注意還是 i，而不是 i-1，因為可以重複用）

綜合起來：  

- 若 `j >= coin`：  
  `dp[i][j] = dp[i-1][j] + dp[i][j - coin]`
- 若 `j < coin`：  
  `dp[i][j] = dp[i-1][j]`（硬幣太大，沒辦法用）

答案為： `dp[n][amount]`。

### 二維 DP 偽碼（接近 C++，但保留為骨架）

```cpp
int change(int amount, vector<int>& coins) {
    int n = coins.size();
    // dp[i][j]：用前 i 種硬幣湊出金額 j 的方案數
    vector<vector<long long>> dp(n + 1, vector<long long>(amount + 1, 0));

    dp[0][0] = 1; // base case

    for (int i = 1; i <= n; ++i) {
        int coin = coins[i - 1];
        for (int j = 0; j <= amount; ++j) {
            // 不用第 i 種硬幣
            dp[i][j] = dp[i - 1][j];
            // 若可以用第 i 種硬幣，再加上用它的情況
            if (j >= coin) {
                dp[i][j] += dp[i][j - coin];
            }
        }
    }

    return (int)dp[n][amount];
}
```

> 筆記：  
> - `dp[i][j - coin]` 代表「已經決定要用至少一枚第 i 種硬幣，剩下的金額用前 i 種繼續湊」。  
> - 這個寫法的好處是「狀態意義非常清楚」，比較不容易搞錯，但空間是 `O(n * amount)`。  

---

## 解法二：一維 DP（空間優化版）

### 狀態定義（改成一維）

用一個一維陣列：  

> `dp[j]` = **用目前已經處理過的那些硬幣，湊出金額 `j` 的方案數**。  

初始化：  

- `dp[0] = 1`：湊出 0 元的方式只有「什麼都不拿」。  
- 其他 `dp[j>0] = 0`。  

### 迴圈順序（非常重要）

我們對每一種硬幣 `coin`：「更新所有金額 j」。  

```cpp
for (coin in coins) {              // 外層：硬幣
    for (j = coin; j <= amount; ++j) {  // 內層：金額，遞增
        dp[j] += dp[j - coin];
    }
}
```

解釋：  

- 當處理到某個 `coin` 時：  
  - `dp[j]` 原本代表「只用前面那些硬幣」湊出 j 的方式數；  
  - `dp[j - coin]` 則代表「只用前面那些硬幣 + 當前 coin」湊出 j-coin 的方式數；  
  - 加上 `coin` 一枚，就能變成湊出 j 的新方式。  
- 由於 j 是從小到大遞增，所以：  
  - 每種 `coin` 更新 `dp` 的過程中，不會重複把「硬幣順序不同」的情況算多次；  
  - 這樣保證算的是「組合」而不是「排列」。  

### 一維 DP 偽碼（接近 C++，但略為骨架）

```cpp
int change(int amount, vector<int>& coins) {
    vector<int> dp(amount + 1, 0);
    dp[0] = 1; // base case

    // 外層：遍歷每一種硬幣（確保是「組合」而不是「排列」）
    for (int coin : coins) {
        // 內層：金額從 coin 跑到 amount（遞增）
        for (int j = coin; j <= amount; ++j) {
            // 新的方式：在「湊出 j - coin 的所有方式」後面再加 1 枚 coin
            dp[j] += dp[j - coin];
        }
    }

    return dp[amount];
}
```

### 複雜度分析

- 時間複雜度：`O(n * amount)`  
- 空間複雜度：  
  - 二維 DP：`O(n * amount)`  
  - 一維 DP：`O(amount)`  

---

## 筆記與心得

1. **關鍵觀念：撇除 & 扣掉**
   - 對每一種硬幣 `coin`、每個金額 `j`：  
     - 「**撇除不用這個硬幣**」→ 延續原本的 `dp[i-1][j]` 或一維版的舊 `dp[j]`。  
     - 「**如果 j >= coin，就可以扣掉一枚 coin**」→ 加上 `dp[i][j-coin]`（二維）或 `dp[j-coin]`（一維）。  
   - 這兩個概念結合起來，就自然得到轉移式：  
     > `目前的方案數 = 不用這個硬幣的方案 + 至少用一枚這個硬幣的方案`。  

2. **為什麼一維版外層要是硬幣，內層是金額遞增？**
   - 外層是硬幣：確保每種硬幣只被「引入一次」，不會因為順序不同造成重複計數。  
   - 內層金額 j 遞增：在同一個硬幣處理過程中，`dp[j - coin]` 代表「可以用目前這個硬幣多次」，符合「完全背包」的性質。  

3. **常見錯誤點**
   - 把 j 的迴圈寫成「遞減」，就會變成「0-1 背包」邏輯（每種硬幣只能用一次），答案會錯。  
   - 外層如果是 `j`、內層是 `coin`，就容易數到「排列」而不是「組合」。  
   - 在二維 DP 中，寫成 `dp[i][j] = dp[i-1][j] + dp[i-1][j-coin]` 也會變成「每種硬幣最多用一次」，不符合本題「無限枚」的設定。  

4. **自己理解後的口語版總結**
   - 「這題就是：**對每個金額 j，方法數 = 不用這枚硬幣的方式＋至少用一枚這枚硬幣的方式**。」  
   - 一維版本的迴圈順序就是在確保「只算組合，不算排列」，而且順手把空間壓到 `O(amount)`。  

