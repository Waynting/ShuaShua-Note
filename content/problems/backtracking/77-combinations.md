---
title: "77. Combinations"
problemId: 77
difficulty: Medium
source: LeetCode
topics: Backtracking, DFS
---

# 77. Combinations

## 題目描述（中文整理）

給定兩個整數 //n// 和 //k//，從區間 [1, n] 中選出恰好 //k// 個不同的整數，列出「所有可能的組合」。  
注意：「組合」不考慮順序，例如 [1,2] 和 [2,1] 視為同一個組合，只保留一個。

---

## 解題思路

### 核心觀念：回溯（Backtracking）產生所有組合

1. **狀態表示**
   - 用一個動態陣列 `path` 表示「目前已經選了哪些數字」。
   - 用一個整數 `start` 表示「這一層 DFS 從哪一個數字開始試」。

2. **終止條件**
   - 當 `path.size() == k` 時，代表已經選滿 k 個數字：
     - 把目前的 `path` 複製一份丟進答案 `ans`。
     - 然後 return（不再往下選）。

3. **狀態轉移（DFS 展開）**
   - 在 `dfs(start, ...)` 這一層，我們會嘗試加入所有可以選的數字：
     - 對 `i` 從 `start` 到 `n`：
       1. 選 `i`：`path.push_back(i)`
       2. 往下一層：呼叫 `dfs(i + 1, ...)`
          - 因為組合不能重複，下一層只能選比 `i` 更大的數字。
       3. 回溯：`path.pop_back()` 恢復現場，準備試下一個 `i`。

4. **避免重複的關鍵**
   - 透過 `start` 參數限制：
     - 目前選了 `i` 之後，下一層只能從 `i+1` 開始選。
     - 這樣自然就不會出現 [2,1] 這種「顛倒順序」的重複情況。

5. **時間與空間複雜度（粗略估計）**
   - 總共會產生 //C(n, k)// 個組合，每個組合長度是 //k//。
   - **時間複雜度**：約為 //O(k · C(n, k))//。
   - **空間複雜度**：
     - 遞迴深度最多 //k//（因為最多選 k 個數），需要 //O(k)// 的額外空間。
     - 回傳的答案本身需要儲存所有組合，額外是 //O(k · C(n, k))//。

---

## 解法 1：回溯（DFS + path + start）

### 思路（口語版）

- 想像人工做 n=4, k=2：
  - 先固定第一個數字：1，後面只能從 {2,3,4} 再選一個。
  - 再固定第一個數字：2，後面只能從 {3,4} 再選一個。
  - 再固定 3，後面只能從 {4} 再選一個。
  - 選 4 時，後面已經沒有數可以選了。
- 這個「先決定當前位置要放的數，再往後遞迴」的過程，就是 DFS。

### C++ 程式骨架（保留為筆記用，不是唯一寫法）

```cpp
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> path;
        // 從 1 開始嘗試選數字
        dfs(1, n, k, path, ans);
        return ans;
    }

private:
    void dfs(int start, int n, int k,
             vector<int>& path,
             vector<vector<int>>& ans) {
        // 1. 終止條件：如果 path.size() == k，把 path 丟進 ans
        if (path.size() == k) {
            ans.push_back(path);   // 已選滿 k 個，記錄一個組合
            return;
        }

        // 2. 從 start 開始一路選到 n
        for (int i = start; i <= n; ++i) {
            // 選 i
            path.push_back(i);

            // 往下層找下一個數（只能比 i 大）
            dfs(i + 1, n, k, path, ans);

            // 撤銷選擇（回溯）
            path.pop_back();
        }
    }
};
```

> 註：上面這份程式與你目前寫出的版本結構相同，只是有稍微補上中文註解，方便未來回顧。

---

## 可能的優化方向（進階）

如果 //n// 比較大，可以做一點剪枝，減少不必要的遞迴呼叫，例如：

- 當前 `path.size()` 已經是 `sz`，還需要再選 `k - sz` 個。
- 當前迴圈的 `i` 最大不需要到 `n`，因為後面剩的數量可能不夠。

可以把迴圈寫成：

```cpp
for (int i = start; i <= n - (k - (int)path.size()) + 1; ++i) {
    // ...
}
```

這樣可以在某些情況下提前停止迴圈。

---

## Personal Notes（個人筆記）

- 這題是典型「回溯模版題」，重點是記住三個元素：
  1. `path`：目前選了什麼。
  2. `start`：下一個數要從哪裡開始選。
  3. 終止條件：選滿 k 個時，把 `path` 丟進 `ans`。
- 和「排列」不同的地方是：
  - 排列會考慮順序，通常會搭配 `used[]` 陣列。
  - 組合不考慮順序，只往「後面」選，靠 `start` 就能避免重複。
- 回溯題目可以用這題當模板，以後看到「從 1..n 選 k 個」「輸出所有子集／組合」時，幾乎都是這種模式。
