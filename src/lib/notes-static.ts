// 自動生成的筆記數據文件 - 請勿手動編輯
export interface Note {
  id: string;
  title: string;
  category: 'dataStructure' | 'algorithm' | 'technique' | 'concept';
  topics: string[];
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  description: string;
  contentPath: string;
  createdAt: string;
  updatedAt: string;
  markdownContent?: string;
}

export const NOTE_CATEGORIES = {
  dataStructure: 'Data Structures',
  algorithm: 'Algorithms',
  technique: 'Problem-Solving Techniques',
  concept: 'Core Concepts'
} as const;

export const NOTES: Note[] = [
  {
    "id": "backtracking",
    "title": "Backtracking（回溯法）",
    "category": "algorithm",
    "topics": [
      "Backtracking",
      "DFS",
      "Recursion"
    ],
    "difficulty": "intermediate",
    "description": "回溯法逐步探索所有可能的選擇，形成決策樹。若某選擇導致死路，則回退並嘗試另一條路徑。",
    "contentPath": "/content/notes/algorithms/backtracking.md",
    "createdAt": "2025-10-03",
    "updatedAt": "2025-10-03",
    "markdownContent": "# Backtracking（回溯法）\n\n## 概述\n回溯法逐步探索所有可能的選擇，形成決策樹。若某選擇導致死路，則「回退」（撤銷上一步決策）並嘗試另一條路徑。\n\n## 1. 核心概念（What & Why）\n- **直觀解釋**：回溯法逐步探索所有可能的選擇，形成決策樹。若某選擇導致死路，則「回退」（撤銷上一步決策）並嘗試另一條路徑。\n- **解決的問題類型**：子集、排列、組合、分割問題、N 皇后、數獨、單詞搜尋、約束滿足問題。\n- **適用條件 / 訊號**：當我們需要**所有解**（不只是一個解），特別是有分支決策時（選或不選、放或不放）。\n- **時間 / 空間複雜度目標**：通常 O(k * 解的數量) / O(n) 遞迴深度。\n- **常用資料結構**：遞迴堆疊、vector/path 來儲存當前解。\n\n---\n\n## 2. 不變性與性質\n- **核心不變性**：\n  - 每次遞迴呼叫代表一個決策狀態。\n  - 路徑（部分解）必須始終有效。\n- **如何維護**：\n  - 加入元素 → 遞迴 → 移除元素（恢復狀態）。\n- **常見陷阱**：\n  - 忘記回溯（pop/remove），導致錯誤結果。\n  - 未處理重複元素 → 產生重複解。\n  - 錯誤的基礎情況 → 遺漏或額外的解。\n\n---\n\n## 3. 常見解題模式\n- **模式 A：子集（對每個元素選或不選）**\n  - 思考過程：對每個元素，選擇包含或跳過 → 向下遞迴。\n  - 複雜度：O(2^n)。\n- **模式 B：組合 / 排列**\n  - 思考過程：建構部分序列直到達到目標大小，必要時避免重複使用。\n  - 複雜度：排列 O(n!)，組合 O(C(n, k))。\n\n---\n\n## 4. 虛擬碼（語言無關架構）\n```text\nfunction dfs(index, path):\n    record(path)  # 若問題需要\n    for i in range(index, n):\n        if i > index and nums[i] == nums[i-1]: continue  # 跳過重複\n        path.push(nums[i])\n        dfs(i+1, path)\n        path.pop()  # 回溯\n```\n\n---\n\n## 5. 各語言語法速查表\n\n### C++\n```cpp\nvector<vector<int>> ans;\nvector<int> path;\n\nvoid dfs(int start, vector<int>& nums) {\n    ans.push_back(path); // 記錄當前子集\n\n    for (int i = start; i < nums.size(); i++) {\n        if (i > start && nums[i] == nums[i-1]) continue; // 跳過重複\n        path.push_back(nums[i]);\n        dfs(i + 1, nums);\n        path.pop_back(); // 回溯\n    }\n}\n```\n\n---\n\n## 6. 最小可行範例（MWE）\n- **輸入**：nums = [1,2,2]\n- **手動步驟**：\n  - [] → [1] → [1,2] → [1,2,2]\n  - 回溯 → [1,2] → 回溯 → [1]\n  - 跳過重複 → [2], [2,2], []\n- **輸出**：[[], [1], [1,2], [1,2,2], [2], [2,2]]\n- **正確性**：每條路徑對應一個子集，避免了重複。\n\n---\n\n## 7. 邊界情況與測試\n```\nCase1: nums = [] → [[]]\nCase2: nums = [1] → [[], [1]]\nCase3: nums = [1,1] → [[], [1], [1,1]]\nCase4: nums = [1,2,2] → [[], [1], [1,2], [1,2,2], [2], [2,2]]\n```\n\n---\n\n## 8. 與相鄰概念的關係\n- 類似於 DFS，但應用於*選擇樹*而非圖遍歷。\n- 可與剪枝結合以減少搜尋空間。\n- 與遞迴、分治法、暴力搜尋相關。\n\n---\n\n## 9. 實作骨架（練習用）\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        vector<int> path;\n        dfs(0, nums, path, ans);\n        return ans;\n    }\n\nprivate:\n    void dfs(int start, vector<int>& nums, vector<int>& path, vector<vector<int>>& ans) {\n        // TODO: 記錄當前路徑\n        for (int i = start; i < nums.size(); i++) {\n            // TODO: 在同一深度跳過重複\n            path.push_back(nums[i]);\n            dfs(i+1, nums, path, ans);\n            path.pop_back();\n        }\n    }\n};\n```\n\n---\n\n## 10. 常見題目\n- LeetCode:\n  - [ ] 78. Subsets\n  - [ ] 90. Subsets II\n  - [ ] 46. Permutations\n  - [ ] 77. Combinations\n  - [ ] 51. N-Queens\n- 其他：經典數獨解題器\n\n---\n\n## 11. 練習計畫\n- Day 0: 實作 subsets / subsets II\n- Day 2: 做 permutations、combinations\n- Day 7: N-Queens、Sudoku\n- Day 21: 複習 + 應用在約束滿足問題\n\n---\n\n## 12. 個人筆記\n- 記住：「加入 → 遞迴 → 移除」是口訣。\n- 當可能出現重複時，總是先排序。\n- 畫出決策樹以視覺化遞迴流程。\n\n---\n\n## 13. 參考資料\n- CLRS, Backtracking 章節\n- LeetCode 討論區（Subsets / Permutations / N-Queens）\n- CP-Algorithms: Backtracking 基礎\n"
  },
  {
    "id": "connected-component",
    "title": "Connected Component（連通分量）",
    "category": "algorithm",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/algorithms/connected-component.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-12-16",
    "markdownContent": "> **來源**：[演算法筆記 - Connected Component](https://web.ntnu.edu.tw/~algo/ConnectedComponent.html)\n> **核心觀念**：當圖上有環，難以設計有效率的演算法。收縮所有的環，讓圖變成樹、有向無環圖，就容易解決問題了！\n\n---\n\n## 一、Connected Component（連通分量）\n\n![Connected Component 示意圖](https://web.ntnu.edu.tw/~algo/ConnectedComponent1.png)\n\n### 定義\n\n當一張**無向圖不連通**、分隔成幾個區塊的時候，每一個區塊都是一個「連通分量」。\n\n### 特性\n\n- **無法互相重疊**\n- 指在連通情況下**點數最多、擴展範圍最大**的子圖\n- 利用 **Graph Traversal（BFS/DFS）** 可找到所有連通分量\n\n### 求法\n\n```\nfor v in 1..N:\n    if v not visited:\n        # 以 v 為新分量起點\n        run BFS/DFS from v\n        # 這一輪走訪到的所有點，構成一個連通分量\n```\n\n### 相關題目\n\n- UVa 459、10765\n\n---\n\n## 二、Biconnected Component（雙連通分量，BCC）\n\n![Biconnected Component 示意圖](https://web.ntnu.edu.tw/~algo/ConnectedComponent2.png)\n\n### 定義\n\n不會產生**關節點（Articulation Point）** 的連通分量，稱作「雙連通分量」。\n\n### 特性\n\n- 通常**互相重疊**，重疊部分為原圖的**關節點**\n- 收縮後形成 **Block-Cutvertex Tree** 結構\n\n### 關節點\n\n- 移除該點後，圖會變成不連通\n- BCC 之間的交點就是關節點\n\n---\n\n## 三、Bridge-Connected Component（橋連通分量）\n\n![Bridge-Connected Component 示意圖](https://web.ntnu.edu.tw/~algo/ConnectedComponent3.png)\n\n### 定義\n\n不會產生**橋（Bridge）** 的連通分量，稱作「橋連通分量」。\n\n### 特性\n\n- 一個橋連通分量，是由**很多環交疊**而成的\n- 橋：移除該邊後，圖會變成不連通\n\n### 相關題目\n\n- ICPC 5135、4839、7605\n\n---\n\n## 四、Strongly Connected Component（強連通分量，SCC）\n\n![Strongly Connected Component 示意圖](https://web.ntnu.edu.tw/~algo/ConnectedComponent4.png)\n\n### 定義\n\n在**有向圖**中，所有兩點之間，**雙向皆有路可通**的連通分量。\n\n### 特性\n\n- **無法互相重疊**\n- 由多個**有向環交疊**而成\n- 收縮後形成 **DAG（有向無環圖）**\n\n### 相關題目\n\n- UVa 11504、11709、11770、11838\n\n---\n\n## 五、Weakly Connected Component（弱連通分量）\n\n### 定義\n\n在有向圖中，所有兩點之間，**至少單向有路可通**的連通分量。\n\n### 特性\n\n- 通常**互相重疊**\n- 比 SCC 條件寬鬆\n\n### 相關題目\n\n- UVa 11324\n\n---\n\n## 六、Tarjan's Algorithm\n\nTarjan 演算法可用於找出各種連通分量，核心思想是利用 DFS 配合時間戳記。\n\n### 無向圖：找 BCC 並收縮環\n\n![Tarjan 無向圖示意](https://web.ntnu.edu.tw/~algo/ConnectedComponent5.png)\n\n**核心概念**：\n- `visit[i]`：節點 i 的訪問時間戳\n- `low[i]`：節點 i 能到達的最小時間戳（最高祖先）\n- 使用 **stack** 追蹤當前 BCC 的節點\n\n**偽碼骨架**：\n\n```cpp\nvoid DFS(int i, int p) {   // p = parent\n    visit[i] = low[i] = ++t;\n    stack[top++] = i;\n\n    for (int j : adj[i]) {\n        if (!visit[j]) {\n            DFS(j, i);\n        }\n        // 避免走回父親那條邊（處理重邊情況）\n        if (!(j == p && adj[i][j] == 1)) {\n            low[i] = min(low[i], low[j]);\n        }\n    }\n\n    // 如果 i 是一個 BCC 的根\n    if (visit[i] == low[i]) {\n        int j;\n        do {\n            j = stack[--top];\n            contract[j] = i;  // 收縮到代表點\n        } while (i != j);\n    }\n}\n```\n\n### 有向圖：找 SCC\n\n![Tarjan 有向圖示意](https://web.ntnu.edu.tw/~algo/ConnectedComponent6.png)\n\n**與無向圖的關鍵差異**：\n- 需要額外的 `instack[]` 陣列追蹤**尚未形成 SCC** 的節點\n- forward edge / cross edge 連到**已移出 stack** 的 SCC 時，不計入 `low` 值\n\n**偽碼骨架**：\n\n```cpp\nvoid DFS(int i) {\n    visit[i] = low[i] = ++t;\n    stack[top++] = i;\n    instack[i] = true;\n\n    for (int j : adj[i]) {\n        if (!visit[j]) {\n            DFS(j);\n        }\n        // 只有還在 stack 中的節點才計入\n        if (instack[j]) {\n            low[i] = min(low[i], low[j]);\n        }\n    }\n\n    // 如果 i 是一個 SCC 的根\n    if (visit[i] == low[i]) {\n        int j;\n        do {\n            j = stack[--top];\n            instack[j] = false;\n            contract[j] = i;\n        } while (j != i);\n    }\n}\n```\n\n### 時間複雜度\n\n- **鄰接矩陣**：O(V²)\n- **鄰接表**：O(V + E)\n\n---\n\n## 七、Kosaraju's Algorithm\n\n另一種找 SCC 的方法，利用**反向圖**的特性。\n\n![Kosaraju 示意圖](https://web.ntnu.edu.tw/~algo/ConnectedComponent7.png)\n\n### 原理\n\n1. 在原圖上 DFS，記錄每個點的**完成時間順序**（類似拓樸排序）\n2. 在**反向圖**上，按照完成時間**由大到小**做 DFS\n3. 每棵 DFS tree 對應一個 SCC\n\n### 偽碼骨架\n\n```cpp\nvector<int> finish;  // 記錄完成順序\n\n// 第一次 DFS：原圖\nvoid DFS1(int i) {\n    visit[i] = true;\n    for (int j : adj[i]) {\n        if (!visit[j]) DFS1(j);\n    }\n    finish.push_back(i);  // 後序加入\n}\n\n// 第二次 DFS：反向圖\nvoid DFS2(int i, int c) {\n    scc[i] = c;  // 標記 SCC 編號\n    visit[i] = true;\n    for (int j : radj[i]) {  // radj = 反向邊\n        if (!visit[j]) DFS2(j, c);\n    }\n}\n\nvoid Kosaraju() {\n    // 第一階段\n    for (int i = 0; i < V; i++) {\n        if (!visit[i]) DFS1(i);\n    }\n\n    // 第二階段（反向順序）\n    fill(visit, visit + V, false);\n    int scc_count = 0;\n    for (int i = V - 1; i >= 0; i--) {\n        int v = finish[i];\n        if (!visit[v]) {\n            DFS2(v, scc_count++);\n        }\n    }\n}\n```\n\n### 時間複雜度\n\n- **鄰接矩陣**：O(V²)\n- **鄰接表**：O(V + E)\n\n---\n\n## 八、2-Satisfiability（2-SAT）\n\n![2-SAT 示意圖](https://web.ntnu.edu.tw/~algo/2-Satisfiability1.png)\n\n### 問題描述\n\n給定一個**合取範式（CNF）**，每個子句恰好有**兩個 literal**：\n\n```\n(X₁ or Y₁) and (X₂ or Y₂) and ... and (Xₙ or Yₙ)\n```\n\n判斷是否存在一組布林賦值使整個式子為真。\n\n### 轉換為有向圖\n\n**邏輯轉換規則**：\n\n| 子句形式 | 等價於 | 對應的邊 |\n|---------|--------|---------|\n| (X or Y) | (¬X → Y) ∧ (¬Y → X) | ¬X → Y, ¬Y → X |\n| (X or X) | (¬X → X) | ¬X → X |\n| (X or ¬X) | 恆真 | 無需加邊 |\n\n### 可解性判定\n\n**關鍵定理**：2-SAT 有解 ⟺ 對於所有變數 X，**X 與 ¬X 不在同一個 SCC** 中。\n\n> 若 X 與 ¬X 在同一個 SCC，代表 X → ¬X 且 ¬X → X 都成立，矛盾！\n\n### 求解方法一：DFS 嘗試\n\n- 對每個變數，嘗試設定其值\n- 檢查是否產生矛盾\n- 時間複雜度：O(VE)\n\n### 求解方法二：SCC + 拓樸排序\n\n![2-SAT 求解](https://web.ntnu.edu.tw/~algo/2-Satisfiability5.png)\n\n**步驟**：\n1. 建立蘊含圖\n2. 找出所有 SCC\n3. 收縮成 DAG\n4. 按**逆拓樸順序**，對每個 SCC 設定值\n\n**關鍵觀察**：\n- 若 SCC(X) 的拓樸序在 SCC(¬X) 之後，則設 X = true\n- 等價於：選擇**拓樸序較大**的那個\n\n**偽碼骨架**：\n\n```cpp\n// 變數 i 對應節點 i（表示 Xᵢ）\n// 變數 i 的否定對應節點 i + N（表示 ¬Xᵢ）\n\nvoid solve() {\n    // 1. 找所有 SCC（用 Tarjan 或 Kosaraju）\n    find_SCC();\n\n    // 2. 檢查可解性\n    for (int i = 0; i < N; i++) {\n        if (scc[i] == scc[i + N]) {\n            // X 與 ¬X 在同一個 SCC，無解\n            return UNSATISFIABLE;\n        }\n    }\n\n    // 3. 依據 SCC 編號決定變數值\n    // Tarjan 產生的 SCC 編號天然是逆拓樸序\n    for (int i = 0; i < N; i++) {\n        // scc 編號較小 = 拓樸序較大 = 選這個\n        answer[i] = (scc[i] > scc[i + N]);\n    }\n}\n```\n\n**時間複雜度**：O(V + E)\n\n### 相關題目\n\n- UVa 10319、11294、11861、11930\n- ICPC 3211、3713、4452、4849\n\n---\n\n## 九、總結對照表\n\n| 類型 | 適用圖 | 是否重疊 | 收縮後結構 | 主要演算法 |\n|-----|-------|---------|-----------|-----------|\n| Connected Component | 無向 | 否 | 多個獨立點 | BFS/DFS |\n| Biconnected Component | 無向 | 是（關節點） | Block-Cutvertex Tree | Tarjan |\n| Bridge-Connected Component | 無向 | 否 | Tree | Tarjan |\n| Strongly Connected Component | 有向 | 否 | DAG | Tarjan / Kosaraju |\n| Weakly Connected Component | 有向 | 是 | — | BFS/DFS（忽略方向） |\n\n---\n\n## 十、練習題建議\n\n### 基礎連通分量\n- UVa 459、10765\n\n### BCC / 關節點 / 橋\n- ICPC 5135、4839、7605\n\n### SCC\n- UVa 11504、11709、11770、11838\n- UVa 11324（Weakly Connected）\n\n### 2-SAT\n- UVa 10319、11294、11861、11930\n- ICPC 3211、3713、4452、4849\n\n---\n\n## 十一、自我檢查\n\n1. **Tarjan 與 Kosaraju 的差異**？各有什麼優缺點？\n2. **為什麼 SCC 收縮後一定是 DAG**？\n3. **2-SAT 為什麼可以用 SCC 求解**？背後的邏輯是什麼？\n4. **如何從 SCC 的拓樸序得到 2-SAT 的解**？\n\n> **結語**：連通分量是圖論的基礎，掌握 Tarjan 和 Kosaraju 後，很多複雜問題都能轉化成 DAG 上的 DP 或拓樸排序來解決。\n"
  },
  {
    "id": "graph-traversal-bipartite",
    "title": "圖的基本遍歷與二分檢查（學習筆記）",
    "category": "algorithm",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/algorithms/graph-traversal-bipartite.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-12-16",
    "markdownContent": "> **用途**：本筆記作為入門與速查，聚焦「無向圖」的遍歷與二分檢查。  \n> **風格**：概念優先、流程清晰、只給**偽碼骨架**（不含可提交實作）。\n\n## 一、基本名詞與模型\n\n- **圖 (Graph)**：由「頂點（vertices）」與「邊（edges）」組成。本文默認**無向簡單圖**（不含自環與重邊）。\n- **表示法**：\n  - **鄰接表**：`adj[v]` 存所有與 `v` 相鄰的頂點。空間 ~ `O(N + M)`，遍歷友好。\n  - **鄰接矩陣**：`mat[v][u]` 是否有邊。空間 ~ `O(N^2)`，適合密集圖、小圖。\n- **連通分量 (Connected Component)**：圖可分成幾塊彼此可達的子圖；遍歷時常需要**從每個未訪問點**重新起始。\n\n## 二、遍歷總覽：BFS 與 DFS\n\n### 2.1 BFS（廣度優先）\n- **核心**：分層擴張，使用**佇列**。適合最短邊數距離、二分染色。\n- **不變量**：\n  1. 佇列中的點，其距離層級（從起點）不遞減。\n  2. 每條已出佇列的點都已處理過鄰居。\n\n**偽碼骨架（單源起點 `s`）**\n```\nqueue Q\nmark s as visited\nQ.push(s)\nwhile Q not empty:\n    v = Q.pop()\n    for each neighbor u of v:\n        if u not visited:\n            mark u as visited\n            Q.push(u)\n```\n> 多分量時：對每個未訪問節點 `x`，各自啟動一次 BFS。\n\n### 2.2 DFS（深度優先）\n- **核心**：一路深入再回溯，**遞迴或顯式堆疊**。\n- **觀念**：會自然生成 DFS 樹，可辨識「樹邊／回邊」，在無向圖中**回邊**代表存在環。\n\n**偽碼骨架（遞迴版）**\n```\nfunction DFS(v, parent):\n    mark v as visited\n    for each neighbor u of v:\n        if u not visited:\n            DFS(u, v)\n        else if u != parent:\n            # 在無向圖中出現回邊 → 有環\n```\n> 遞迴深度可能達 `N`；在工程中可改成顯式堆疊。\n\n### 2.3 連通分量的取得\n```\nfor v in 1..N:\n    if v not visited:\n        # 以 v 為新分量起點\n        run BFS/DFS from v\n```\n\n## 三、二分圖（Bipartite）與奇環\n\n- **定義**：可把頂點分成兩色（黑/白），**每條邊兩端顏色不同**。\n- **等價條件（無向圖）**：**沒有奇數長度的環（奇環）** ⇔ 是二分圖。\n- **直觀**：BFS/DFS 以「層級奇偶」作為顏色；若遇到一條邊連到**相同顏色**的點 → 發生**顏色衝突** ⇒ 有奇環 ⇒ 非二分。\n\n## 四、二分檢查：遍歷 + 染色\n\n### 4.1 流程概念\n1. **多分量**：對每個未訪問節點作為起點。\n2. 起點染色（例如色 `0`），並以 BFS 或 DFS 擴張。\n3. 每當走到一條邊 `(v,u)`：\n   - 若 `u` 未染色：賦予 `u` = `1 - color[v]`。\n   - 若 `u` 已染色且 `color[u] == color[v]` → **衝突**（即存在奇環）→ 非二分。\n\n### 4.2 偽碼骨架（BFS 染色，多分量）\n```\ncolor[] = UNCOLORED\nfor each vertex s in 1..N:\n    if color[s] == UNCOLORED:\n        color[s] = 0\n        queue Q; Q.push(s)\n        while Q not empty:\n            v = Q.pop()\n            for u in adj[v]:\n                if color[u] == UNCOLORED:\n                    color[u] = 1 - color[v]\n                    Q.push(u)\n                else if color[u] == color[v]:\n                    return \"NOT BIPARTITE\"\nreturn \"BIPARTITE\"\n```\n> DFS 版本同理，只是把「推入佇列」換成「遞迴呼叫/壓入堆疊」。\n\n### 4.3 為什麼偵測到同色相鄰就是奇環？\n- BFS 的顏色就是**距離層級的奇偶性**；若存在邊連接**同層級奇偶性**的兩點，則形成一條**奇數長度環**（兩點由樹路徑相連，再加上該邊）。\n\n## 五、時間與空間複雜度\n\n- **時間**：`O(N + M)`，每條邊與節點皆至多被處理常數次。\n- **空間**：`O(N + M)`（鄰接表） + `O(N)`（佇列或遞迴堆疊）。\n\n## 六、常見陷阱與排錯心法\n\n1. **只從 1 起走、忽略其他分量** → 漏檢。  \n2. **把自環、重邊當成一般邊**：\n   - 自環（`v` 連 `v`）直接判「非二分」；\n   - **重邊**（`u`—`v` 重複）在無向圖不會單獨造成奇環，但要當作兩條平行邊處理輸入。\n3. **遞迴爆棧**：節點數大時用顯式堆疊或 BFS。  \n4. **顏色初始化**：務必把「未染色」與 `0/1` 區分清楚。  \n5. **索引混亂**：題目若 1-index，程式中 0-index 要一致轉換。  \n6. **方向誤解**：本文方法適用**無向圖**；有向圖的「二分圖」概念不同。\n\n## 七、延伸與變體（概念）\n\n- **邊權／點權**：二分檢查與權重無關（只看結構）。  \n- **找一個奇環證據**：衝突當下可沿父親指標回朔，輸出一條奇環（學術上常用）。  \n- **二分圖結構應用**：最大匹配（Hopcroft–Karp）、最小點覆蓋（Kőnig 定理）、網路流建模等。\n\n## 八、練習題建議（純題名，便於自查）\n- **785. Is Graph Bipartite?**（無向圖二分檢查基本題）  \n- **886. Possible Bipartition**（把人分兩派、衝突邊表示不能同色）  \n- **200. Number of Islands**（練 BFS/DFS 遍歷與分量計數）  \n- **547. Number of Provinces**（圖的分量）  \n- **994. Rotting Oranges**（BFS 層級擴張的節奏感）\n\n## 九、微練習（自我檢查）\n1. 為何「沒有奇環」就一定能二分染色？反方向又為何成立？  \n2. 若圖是一片森林（所有分量皆樹），需要做什麼就能保證二分？  \n3. 在 BFS 染色中，遇到 `(v,u)` 且 `color[u] == color[v]`，試用「樹路徑 + 這條邊」畫出對應奇環的構造。\n\n## 十、附錄：顯式堆疊的 DFS 染色骨架（僅供思路）\n```\nstack S\ncolor[s] = 0\nS.push(s)\nwhile S not empty:\n    v = S.pop()\n    for u in adj[v]:\n        if color[u] == UNCOLORED:\n            color[u] = 1 - color[v]\n            S.push(u)\n        else if color[u] == color[v]:\n            return \"NOT BIPARTITE\"\nreturn \"BIPARTITE\"\n```\n\n> **結語**：做題時，**先分量、後染色** 是穩定套路；BFS 尤其適合二分檢查。當你能自然從「衝突」回想到「奇環」，就算真的掌握了。\n"
  },
  {
    "id": "graph_union_notes",
    "title": "Algorithms – Graph Theory & Related String Algorithms (Union Notes)",
    "category": "algorithm",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/algorithms/graph_union_notes.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-12-16",
    "markdownContent": "# Algorithms – Graph Theory & Related String Algorithms (Union Notes)\n\nThese notes merge:\n- 課堂講義：Basic Graph Algorithms, Advanced Graph Algorithms, Reduction, NP-Completeness, Dynamic Programmingfileciteturn2file0turn2file1turn2file2turn2file3turn2file4  \n- 先前整理的：DFS/BFS、SCC、BCC、Shortest Paths、MST、Max Flow、De Bruijn Sequence、Scrambled String DP 等。\n\n---\n\n## 0. 基本圖論概念回顧\n\n我們主要處理 **有限圖** \\(G = (V, E)\\)：\n\n- **頂點 (vertex / node)**：集合 \\(V\\)。  \n- **邊 (edge / link)**：集合 \\(E\\)，每條邊連接一或兩個頂點。  \n- **無向圖 / 有向圖 (undirected / directed)**：邊是否具有方向。  \n- **加權圖 (weighted graph)**：每條邊有權重 \\(w(e)\\)（長度、成本、容量等）。  \n- **路徑 path**：頂點序列，每對相鄰頂點之間有邊。  \n- **簡單路徑 simple path**：除起點與終點外，不重複頂點。  \n- **圈 / cycle**：起點與終點相同的簡單路徑。  \n- **連通圖 connected graph**：任兩點間存在路徑。  \n- **生成樹 spanning tree**：\n  - 子圖，包含所有頂點；  \n  - 無圈且連通；對連通圖，邊數必為 \\(|V|-1\\)。  \n- **強連通 strongly connected (有向圖)**：任兩點間皆有有向路徑。  \n- **強連通分量 SCC**：極大強連通子圖。fileciteturn2file1  \n- **雙連通 biconnected (無向圖)**：任兩點間存在至少兩條點互斥路徑；移除任一頂點仍連通。  \n- **雙連通分量 BCC**：極大雙連通子圖。fileciteturn2file1  \n\n---\n\n## 1. 深度優先搜尋 DFS\n\n### 1.1 直覺\n\n從某個起點出發，每次「往一條路走到底」，走不下去才回頭。是一種系統性探索整張圖的方法。fileciteturn2file0  \n\n### 1.2 基本遞迴版 DFS\n\n```pseudo\nAlgorithm DFS(G):\n    for each vertex v in V(G) do\n        visited[v] := false\n\n    for each vertex v in V(G) do\n        if not visited[v] then\n            DFS_visit(G, v)\n\nprocedure DFS_visit(G, v):\n    visited[v] := true\n    preWORK(v)         // 可選，用來做各種應用\n\n    for each edge (v, w) in E(G) do\n        if not visited[w] then\n            DFS_visit(G, w)\n            postWORK(v, w)   // 可選：回溯時要做的事\n\n    postWORK2(v)       // 可選：離開 v 時做的事\n```\n\n> 課堂版本 `Depth First Search(G, v)` / `Refined DFS(G, v)` 只是把 `preWORK` / `postWORK` 抽象化。fileciteturn2file0  \n\n### 1.3 DFS 編號 & DFS 樹\n\n- **DFS Number**：第一個造訪某個頂點的順序編號。  \n- **DFS Tree**：在 DFS 中，所有「第一次造訪某個未標記頂點」所走的邊稱為 **樹邊 (tree edge)**，構成 DFS 樹或 DFS 森林。fileciteturn2file0  \n\n```pseudo\nAlgorithm DFS_Numbering(G):\n    for each v in V:\n        visited[v] := false\n    time := 1\n    for each v in V:\n        if not visited[v] then\n            DFS_num(G, v)\n\nprocedure DFS_num(G, v):\n    visited[v] := true\n    DFSNumber[v] := time; time := time + 1\n    for each (v, w) in E:\n        if not visited[w] then\n            parent[w] := v\n            DFS_num(G, w)\n```\n\n### 1.4 連通分量 Connected Components（無向圖）\n\n```pseudo\nAlgorithm Connected_Components(G):\n    for each v in V:\n        visited[v] := false\n    component_id := 0\n\n    for each v in V:\n        if not visited[v] then\n            component_id := component_id + 1\n            DFS_CC(G, v, component_id)\n\nprocedure DFS_CC(G, v, id):\n    visited[v] := true\n    comp[v] := id\n    for each (v, w) in E:\n        if not visited[w] then\n            DFS_CC(G, w, id)\n```\n\n時間複雜度 \\(O(|V| + |E|)\\)：每條邊、每個點最多被處理常數次。\n\n### 1.5 有向圖中的邊分類與找環（Directed Cycle）\n\n對有向圖，根據 DFS 樹可以把邊分成：\n\n- **tree edge**：造訪未標記頂點時用到的邊。  \n- **back edge**：從某點指向 DFS 樹中的祖先節點。  \n- **forward edge**：指向自己的後代，但不是 tree edge。  \n- **cross edge**：其他情況（不同子樹之間）。  \n\n重要性質：**存在 back edge ⇔ 有向圖含有有向環**。\n\n#### 偵測有向環的 DFS\n\n講義用 `on_the_path` 記錄目前遞迴堆疊上的節點： \n\n```pseudo\nAlgorithm Has_Directed_Cycle(G):\n    for each v in V:\n        visited[v] := false\n        onStack[v] := false\n\n    for each v in V:\n        if not visited[v] then\n            if DFS_Cycle(G, v) then\n                return true\n    return false\n\nfunction DFS_Cycle(G, v) -> bool:\n    visited[v] := true\n    onStack[v] := true\n\n    for each edge (v, w) in E:\n        if not visited[w] then\n            if DFS_Cycle(G, w) then\n                return true\n        else if onStack[w] then\n            // (v, w) 是 back edge → 有環\n            return true\n\n    onStack[v] := false\n    return false\n```\n\n---\n\n## 2. 廣度優先搜尋 BFS\n\n### 2.1 直覺\n\n一圈一圈擴張的搜尋。對「每條邊權重相同」的圖，BFS 產生的是從起點出發的 **最短路徑樹**。\n\n### 2.2 標準 BFS\n\n```pseudo\nAlgorithm BFS(G, s):\n    for each v in V:\n        visited[v] := false\n        dist[v] := ∞\n        parent[v] := NIL\n\n    create empty queue Q\n    visited[s] := true\n    dist[s] := 0\n    enqueue(Q, s)\n\n    while Q not empty:\n        v := dequeue(Q)\n        preWORK(v)           // optional\n        for each edge (v, w) in E:\n            if not visited[w]:\n                visited[w] := true\n                dist[w] := dist[v] + 1\n                parent[w] := v\n                add edge (v, w) to BFS tree T\n                enqueue(Q, w)\n```\n\n性質：  \n- `dist[v]` = 從 `s` 到 `v` 的「邊數」最少距離。\n\n---\n\n## 3. 拓樸排序 Topological Sorting（DAG）\n\n### 3.1 問題\n\n給一張 **有向無環圖 (DAG)**，希望排出一個順序，使得每條邊 \\((u,v)\\) 中，\\(u\\) 一定在 \\(v\\) 之前。\n\n### 3.2 Kahn 演算法（入度 + Queue）\n\n講義的 `Topological Sorting(G)` 就是這個版本：\n\n```pseudo\nAlgorithm Topological_Sort(G):\n    for each v in V:\n        indeg[v] := 0\n\n    for each edge (u, v) in E:\n        indeg[v] := indeg[v] + 1\n\n    create empty queue Q\n    for each v in V:\n        if indeg[v] = 0:\n            enqueue(Q, v)\n\n    label := 0\n    while Q not empty:\n        v := dequeue(Q)\n        label := label + 1\n        topo[v] := label\n        for each edge (v, w) in E:\n            indeg[w] := indeg[w] - 1\n            if indeg[w] = 0:\n                enqueue(Q, w)\n```\n\n複雜度 \\(O(|V| + |E|)\\)。如果最後沒有處理完所有頂點，代表原圖含有有向環。\n\n---\n\n## 4. Eulerian Circuit（歐拉迴路）\n\n### 4.1 定義與判定\n\n- 在無向連通圖中，一條「走過每條邊恰好一次且回到起點」的閉路稱為 **Eulerian circuit**。  \n- 定理：**若且唯若所有頂點的 degree 皆為偶數，圖才有 Eulerian circuit**。\n\n### 4.2 Hierholzer 演算法（概念）\n\n1. 從任一點出發，沿著還沒走過的邊一路走到回到起點形成一個圈。  \n2. 若圈中尚有頂點有未走過的 incident edge，就在那個頂點再展開一圈，並「插入」原本的圈中。  \n3. 重複直到沒有未走邊。  \n\n（考試通常只問定義與定理、或讓你判斷圖是否 Eulerian；真正 pseudocode 不一定必考。）\n\n---\n\n## 5. 強連通分量 SCC（Tarjan 演算法版本）\n\n講義 `Strongly Connected Components(G,n)` 使用 DFS + stack + High 值。\n\n### 5.1 直覺\n\n- 在同一個 SCC 中，每一對頂點之間都有有向路徑。  \n- Tarjan 的想法：DFS 時，利用「能回溯到的最高 DFS 編號（High）」來判斷一個節點是否是某個 SCC 的「leader」。\n\n### 5.2 演算法概念\n\n- 每個節點有：`DFSNumber[v]`（由 n 遞減）、`High[v]`、`Component[v]`。  \n- 使用一個 **stack** 暫存目前尚未分配 component 的頂點。  \n- DFS 回溯到某個 v 時，若 `High[v] == DFSNumber[v]`，表示以 v 為 leader 的 SCC 已完整探索完畢，從 stack pop 出直到 v 就是一個 SCC。\n\n### 5.3 Pseudocode（接近講義）\n\n```pseudo\nAlgorithm SCC_All(G, n):\n    for each vertex v:\n        DFSNumber[v] := 0\n        Component[v] := 0\n    CurrentComp := 0\n    DFSN := n\n    for each vertex v:\n        if DFSNumber[v] = 0:\n            SCC_DFS(v)\n\nprocedure SCC_DFS(v):\n    DFSNumber[v] := DFSN\n    DFSN := DFSN - 1\n    push v onto Stack\n    High[v] := DFSNumber[v]\n\n    for each edge (v, w):\n        if DFSNumber[w] = 0 then          // tree edge\n            SCC_DFS(w)\n            High[v] := max(High[v], High[w])\n        else if DFSNumber[w] > DFSNumber[v] and Component[w] = 0 then\n            // back / forward / cross edge pointing to not-yet-assigned vertex\n            High[v] := max(High[v], DFSNumber[w])\n            // (講義註解：也可以用 High[w])\n    \n    if High[v] = DFSNumber[v] then\n        CurrentComp := CurrentComp + 1\n        repeat\n            x := pop Stack\n            Component[x] := CurrentComp\n        until x = v\n```\n\n時間複雜度：與 DFS 相同，\\(O(|V|+|E|)\\)。\n\n---\n\n## 6. 雙連通分量 BCC（無向圖）\n\n講義 `Biconnected Components(G,v,n)` 同樣使用 DFS + High 值 + stack，不同的是：  \n- DFSNumber 由 n 遞減；  \n- High[v] = 能回到的最大 DFSNumber；  \n- 當子節點 w 回傳後若 `High[w] <= DFSNumber[v]`，那麼以邊 (v,w) 為界切出一個 BCC。\n\n### 6.1 直覺\n\n- BCC 中任兩點間至少有兩條點互斥路徑。  \n- **割點 (articulation point)**：移除它會讓圖變成不連通。  \n- 事實上，一個割點會屬於多個 BCC。  \n- 根據性質：「兩條邊 e,f 屬於同一 BCC ⇔ 存在一個 cycle 同時包含 e 和 f」。 \n\n### 6.2 Pseudocode（接近課堂版本）\n\n我們用「邊 stack」來存目前 DFS 路徑上的邊。每次切出一個 BCC，就把那個 BCC 的邊全部從 stack pop 出來。\n\n```pseudo\nAlgorithm BCC_All(G, root, n):\n    for each vertex v:\n        DFSNumber[v] := 0\n    DFSN := n\n    create empty stack S    // stack of edges\n\n    BC_DFS(root, parent = NIL)\n\nprocedure BC_DFS(v, parent):\n    DFSNumber[v] := DFSN\n    DFSN := DFSN - 1\n    High[v] := DFSNumber[v]\n\n    for each edge (v, w) in E:\n        if w = parent then\n            continue\n\n        if DFSNumber[w] = 0 then          // tree edge\n            push edge (v, w) onto S\n            BC_DFS(w, v)\n\n            if High[w] <= DFSNumber[v] then\n                // (v, w) 是此 BCC 與上一層的分界\n                output \"New BCC:\"\n                repeat\n                    (x, y) := pop S\n                    output edge (x, y) as part of this BCC\n                until (x, y) = (v, w)\n\n            High[v] := max(High[v], High[w])\n        else if DFSNumber[w] > DFSNumber[v] then\n            // back edge (無向圖以 DFS 編號判斷)\n            push edge (v, w) onto S\n            High[v] := max(High[v], DFSNumber[w])\n```\n\n注意：在 SCC 中使用 `max(High[v], High[w])` 沒問題；但在 BCC 的「非樹邊」情況必須用 `DFSNumber[w]`，不能用 `High[w]`，否則會把跨越多層的資訊吃掉。這也是講義中特別註解的地方。 \n\n---\n\n## 7. 單源最短路徑 SSSP\n\n假設圖為有向加權圖 \\(G=(V,E)\\)，權重可以是負的，但 **沒有負權重環**。\n\n### 7.1 DAG 上的最短路徑（Topological DP）\n\n講義中的 `Acyclic Shortest Paths(G,v,n)`：利用拓樸排序，由「不可能再被更新」的順序處理。 \n\n簡單非遞迴版：\n\n```pseudo\nAlgorithm DAG_SSSP(G, s):\n    topo_order := Topological_Sort(G)\n    for each v in V:\n        dist[v] := ∞\n    dist[s] := 0\n\n    for each u in topo_order:\n        for each edge (u, v) with weight w:\n            if dist[u] + w < dist[v]:\n                dist[v] := dist[u] + w\n```\n\n### 7.2 Dijkstra（所有邊權重非負）\n\n講義 `Single Source Shortest Paths(G, v)`：每次從尚未確定的頂點中選 dist 最小者擴張。\n\n```pseudo\nAlgorithm Dijkstra(G, s):\n    for each v in V:\n        dist[v] := ∞\n        visited[v] := false\n    dist[s] := 0\n\n    while exists unvisited vertex:\n        u := unvisited vertex with minimal dist[u]   // 或用 min-heap\n        visited[u] := true\n        for each edge (u, v) with weight w:\n            if not visited[v] and dist[u] + w < dist[v]:\n                dist[v] := dist[u] + w\n```\n\n- 若用最小堆：時間 \\(O((|V|+|E|)\\log|V|)\\)。\n- **要求所有權重非負**。\n\n### 7.3 DP 版 Bellman–Ford（最多 \\(n-1\\) 條邊）\n\n在 DP 講義裡，定義 \\(D_l(u)\\)：從 s 到 u、最多 l 條邊的最短路徑長度，並寫出遞迴關係：\n\n\\[\nD_1(u) =\n\\begin{cases}\n\t\\text{length}(s,u) & (s,u)\\in E \\\\\n0 & u = s \\\\\n\\infty & \t\\text{otherwise}\n\\end{cases}\n\\]\n\n\\[\nD_l(u) = \\min\\Big( D_{l-1}(u),\\ \\min_{(x,u)\\in E}\\{D_{l-1}(x) + w(x,u)\\} \\Big), \\ 2\\le l\\le n-1\n\\]\n\n實作上可把第一維壓扁成目前 dist 陣列（即一般的 Bellman–Ford）：\n\n```pseudo\nAlgorithm Bellman_Ford(G, s):\n    for each v in V:\n        dist[v] := ∞\n    dist[s] := 0\n\n    // 最多 n-1 輪，每輪放鬆所有邊\n    for i := 1 to |V|-1:\n        for each edge (u, v) with weight w:\n            if dist[u] + w < dist[v]:\n                dist[v] := dist[u] + w\n\n    // 之後再多跑一輪檢查負權重環\n    for each edge (u, v) with weight w:\n        if dist[u] + w < dist[v]:\n            report \"negative-weight cycle exists\"\n```\n\n時間複雜度 \\(O(|V||E|)\\)。\n\n---\n\n## 8. 全源最短路徑 APSP（Floyd–Warshall）\n\nDP 講義中定義：\\(W_k(i,j)\\) 為從 i 到 j 的最短路徑長度，限制中間頂點編號不超過 k。 \n\n遞迴：\n\n\\[\nW_0(i,j) = \\begin{cases}\nw(i,j) & (i,j)\\in E \\\\\n0 & i = j \\\\\n\\infty & \text{otherwise}\n\\end{cases}\n\\]\n\n\\[\nW_k(i,j) = \\min \\big(W_{k-1}(i,j),\\ W_{k-1}(i,k) + W_{k-1}(k,j) \\big)\n\\]\n\n實作：\n\n```pseudo\nAlgorithm Floyd_Warshall(G):\n    for i in 1..n:\n        for j in 1..n:\n            if i = j then dist[i][j] := 0\n            else if (i, j) in E then dist[i][j] := w(i, j)\n            else dist[i][j] := ∞\n\n    for k in 1..n:\n        for i in 1..n:\n            for j in 1..n:\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] := dist[i][k] + dist[k][j]\n```\n\n時間複雜度 \\(O(n^3)\\)。\n\n---\n\n## 9. 最小生成樹 MST（Prim & Kruskal）\n\n### 9.1 定義\n\n在連通無向加權圖中，尋找一棵生成樹，其邊權重總和最小，稱為 **Minimum-Cost Spanning Tree (MCST/MST)**。\n\n### 9.2 Cut Property / Cycle Property（概念）\n\n講義給出：對任何割 \\((V_1, V_2)\\)，跨越割且權重最小的那條邊一定在某棵 MST 中。   其等價描述也是：任何圈內的最大邊不會出現在某棵 MST 中。\n\n### 9.3 Prim 演算法（講義版本）\n\n講義 `MST(G)` 是 Prim 的一個變形：\n\n**概念版 pseudocode：**\n\n```pseudo\nAlgorithm Prim_MST(G):\n    for each v in V:\n        inMST[v] := false\n        bestCost[v] := ∞\n        bestEdge[v] := NIL\n\n    // 任意選一點當起始（講義是選整張圖的最小邊）\n    choose arbitrary root r\n    bestCost[r] := 0\n\n    repeat |V| times:\n        // 找目前還沒在樹中、bestCost 最小的頂點\n        u := argmin_{v | not inMST[v]} bestCost[v]\n        inMST[u] := true\n        if bestEdge[u] ≠ NIL:\n            add bestEdge[u] to MST\n\n        for each edge (u, w) with weight c:\n            if not inMST[w] and c < bestCost[w]:\n                bestCost[w] := c\n                bestEdge[w] := (u, w)\n```\n\n用 min-heap 可達 \\(O((|V|+|E|)\\log|V|)\\)。\n\n### 9.4 Kruskal 演算法（補充）\n\n雖然講義主要講 Prim，但課程通常也會講 Kruskal：\n\n```pseudo\nAlgorithm Kruskal_MST(G):\n    create a disjoint-set DS for all vertices\n    sort all edges e in nondecreasing order by weight\n\n    MST := ∅\n    for each edge (u, v) in sorted edges:\n        if Find(DS, u) ≠ Find(DS, v):\n            MST := MST ∪ {(u, v)}\n            Union(DS, u, v)\n\n    return MST\n```\n\n時間：排序邊 \\(O(|E|\\log|E|)\\) + Union-Find 幾乎線性。\n\n---\n\n## 10. Network Flow & Bipartite Matching Reduction\n\n### 10.1 Network Flow 基本定義\n\n圖 \\(G=(V,E)\\) 有： \n\n- source \\(s\\)、sink \\(t\\)。  \n- 每條邊有容量 \\(c(e) > 0\\)。  \n- flow \\(f(e)\\) 滿足：  \n  1. \\(0 \\le f(e) \\le c(e)\\)。  \n  2. 對所有中間節點 \\(v \ne s,t\\)，流入 = 流出（流量守恆）。  \n\n目標：最大化從 s 到 t 的總流量。\n\n### 10.2 Ford–Fulkerson / Edmonds–Karp（概念版）\n\n2. BFS to find shortest augmenting path（Edmonds–Karp 核心）\n```pseudo\nfunction BFS(residual_capacity, adj, s, t, parent):\n    # Find an s-t path in residual graph using BFS\n    # Return true if path exists; also fill parent[] to record the path.\n\n    for each vertex v:\n        parent[v] := NIL\n\n    create empty queue Q\n    enqueue(Q, s)\n    parent[s] := s    # mark source as visited\n\n    while Q is not empty:\n        u := dequeue(Q)\n\n        for each v in adj[u]:\n            if parent[v] = NIL and residual_capacity[u][v] > 0:\n                parent[v] := u\n                if v = t:\n                    return true   # found s-t path\n                enqueue(Q, v)\n\n    return false      # no s-t path exists\n```\n- `parent[v]` 用來記錄在 BFS 樹裡，v 是從哪個頂點走來的。\n- `residual_capacity[u][v] > 0 `才代表在殘存網路裡有邊可走。\n\n3. Edmonds–Karp Max Flow 演算法\n```pseudo \nfunction EdmondsKarp_MaxFlow(G, capacity, s, t):\n\n    for each vertex u:\n        for each vertex v:\n            residual_capacity[u][v] := capacity[u][v]\n\n    max_flow := 0\n\n    create array parent[ ]  # for reconstructing path\n\n    # While there exists an s-t augmenting path\n    while BFS(residual_capacity, adj, s, t, parent) = true:\n\n        # 1. Find bottleneck capacity along the path\n        bottleneck := +∞\n        v := t\n        while v ≠ s:\n            u := parent[v]\n            if residual_capacity[u][v] < bottleneck:\n                bottleneck := residual_capacity[u][v]\n            v := u\n\n        # 2. Augment flow along the path\n        v := t\n        while v ≠ s:\n            u := parent[v]\n            # forward edge: increase flow from u to v\n            residual_capacity[u][v] := residual_capacity[u][v] - bottleneck\n            # backward edge: allow cancellation of this flow in future\n            residual_capacity[v][u] := residual_capacity[v][u] + bottleneck\n            v := u\n\n        max_flow := max_flow + bottleneck\n\n    return max_flow\n\n```\n\n```pseudo\nAlgorithm Max_Flow(G, s, t):\n    for each edge e:\n        f[e] := 0\n\n    while there exists an s-t augmenting path P in residual graph G_f:\n        bottleneck := min residual capacity on edges of P\n        for each edge e on P:\n            if e is forward edge (u->v):\n                f[e] := f[e] + bottleneck\n            else if e is backward edge (v->u):\n                f[rev(e)] := f[rev(e)] - bottleneck\n\n    return f\n```\n\n- Edmonds–Karp 具體規定「augmenting path 用 BFS 找最少邊數」→ 保證多項式時間。\n\n### 10.3 Bipartite Matching → Max Flow 的 reduction\n\n講義有標準圖：左邊 V，右邊 U，中間是 bipartite edges，然後加 s 與 t。\n\n**構造：**  \n- 原始輸入：二分圖 \\(G=(V,U,E)\\)。  \n- 建新圖 \\(G'=(V',E')\\)：  \n  - \\(V' = \\{s\\} \\cup V \\cup U \\cup \\{t\\}\\)。  \n  - 邊：  \n    - \\((s,v)\\) 對每個 \\(v\\in V\\)，容量 1。  \n    - 原二分圖中的邊 \\((v,u)\\) 變成 \\((v,u)\\)，容量 1。  \n    - \\((u,t)\\) 對每個 \\(u\\in U\\)，容量 1。  \n- 在 \\(G'\\) 上算最大流，流量的 1-edges 對應到一個最大 matching。 \n\n這是典型「圖論問題 → Flow → 線性規劃」三連還原的一部分。\n\n---\n\n## 11. De Bruijn Sequence（字串 / 圖論）\n\n### 11.1 定義\n\n對字母表大小為 \\(k\\)、字串長度為 \\(n\\)：  \n**De Bruijn sequence** \\(B(k,n)\\)：一個循環序列，使得所有 \\(k^n\\) 個長度 n 的字串都恰好一次出現在某個長度為 n 的窗口中。  \n\n例：  \n- \\(B(2,3)=00010111\\) 長度 8；其所有長度 3 的子字串（循環看）剛好就是所有 8 種二進位字串。\n\n### 11.2 DFS 生成演算法（Lyndon word / prefer-0 版本）\n\n常見實作：\n\n```pseudo\nfunction DeBruijn(k, n):\n    // 回傳一個 De Bruijn sequence over alphabet {0..k-1}\n    a[0 .. k*n] := 0\n    sequence := empty list\n\n    procedure db(t, p):\n        if t > n:\n            if n mod p = 0:\n                // output Lyndon word a[1..p]\n                append a[1..p] to sequence\n        else:\n            a[t] := a[t-p]\n            db(t+1, p)\n            for j from a[t-p]+1 to k-1:\n                a[t] := j\n                db(t+1, t)\n\n    db(1, 1)\n    return sequence\n```\n\n輸出長度為 \\(k^n\\)，接下一個字串可以視為一個 Eulerian path / Hamiltonian path 在 De Bruijn graph 中。\n\n---\n\n## 12. Scrambled String 判定（DP）\n\n題目：給長度一樣的字串 A, B，問 A 是否能透過「遞迴切割 & 子字串交換」scramble 變成 B。\n\n### 12.1 DP 狀態\n\n令：  \n\\(S(i,j,k)\\)：Boolean，表示  \n> A[i..i+k-1] 是否可以 scrambling 成 B[j..j+k-1]。fileciteturn2file4  \n\n最終答案：`S(1, 1, n)`。\n\n### 12.2 遞迴關係\n\n長度 k ≥ 2 時，枚舉切割位置 t (1 ≤ t ≤ k-1)：\n\n- 不交換：  \n  - 左半：A[i..i+t-1] → B[j..j+t-1]  \n  - 右半：A[i+t..i+k-1] → B[j+t..j+k-1]\n- 交換：  \n  - 左半：A[i..i+t-1] → B[j+k-t..j+k-1]  \n  - 右半：A[i+t..i+k-1] → B[j..j+k-t-1]\n\n\\[\nS(i,j,k) = \\bigvee_{t=1}^{k-1} \\Big(\n   S(i,j,t)\\land S(i+t, j+t, k-t)\n   \\ \\lor   S(i, j+k-t, t) \\land S(i+t, j, k-t)\n\\Big)\n\\]\n\nBase case：\\(k=1\\)，`S(i,j,1) = (A[i] == B[j])`。\n\n### 12.3 自底向上實作（概念）\n\n```pseudo\nAlgorithm IsScramble(A, B):\n    n := length(A)\n    if n ≠ length(B): return false\n\n    for i in 1..n:\n        for j in 1..n:\n            S[i][j][1] := (A[i] = B[j])\n\n    for k from 2 to n:                  // substring length\n        for i from 1 to n-k+1:\n            for j from 1 to n-k+1:\n                S[i][j][k] := false\n                for t from 1 to k-1:\n                    if ( S[i][j][t] and S[i+t][j+t][k-t] ) or\n                       ( S[i][j+k-t][t] and S[i+t][j][k-t] ) then\n                        S[i][j][k] := true\n                        break\n\n    return S[1][1][n]\n```\n\n時間複雜度約 \\(O(n^4)\\)（三層 i,j,k 再乘一層 t）。\n\n---\n\n## 13. 小結：考試時怎麼抓重點\n\n1. **DFS/BFS/Topological Sort**  \n   - Pseudocode + time complexity。  \n   - DFS：connected components、找 cycle（directed / undirected）、DFS tree 性質。  \n   - BFS：unweighted shortest path。  \n   - Topological sort：DAG + indegree=0 queue。\n\n2. **SCC / BCC**  \n   - 狀態：DFSNumber, High, stack。  \n   - 何時切 component：  \n     - SCC：`High[v] == DFSNumber[v]`。  \n     - BCC：子 w 回來後 `High[w] <= DFSNumber[v]`。  \n\n3. **Shortest Paths**  \n   - DAG + DP、Dijkstra（非負）、Bellman-Ford（負邊）、Floyd-Warshall（APSP）。  \n\n4. **MST**  \n   - Prim / Kruskal 演算法步驟、Cut / Cycle property。  \n\n5. **Network Flow & Matching**  \n   - 流量定義、Ford–Fulkerson 想法、bipartite matching → flow 的構造。  \n\n6. **De Bruijn & Scrambled String**  \n   - 知道 state 定義、遞迴關係、演算法大致流程即可。\n\n---\n\n（完）\n"
  },
  {
    "id": "cpp-stl-map",
    "title": "STL std::map 速查",
    "category": "dataStructure",
    "topics": [
      "C++",
      "STL",
      "Map",
      "Data Structures"
    ],
    "difficulty": "intermediate",
    "description": "有序、唯一鍵的關聯式容器，平衡 BST 實作，依鍵排序。",
    "contentPath": "/content/notes/data-structures/cpp-stl-map.md",
    "createdAt": "2025-10-05",
    "updatedAt": "2025-10-05",
    "markdownContent": "# STL `std::map` 中文速查（以實務使用為主）\n\n> 以 C++17/20/23 為基準。`std::map<Key, T, Compare>` 是 **有序、唯一鍵** 的關聯式容器（平衡 BST，常見為紅黑樹）。元素型別為 `pair<const Key, T>`，**依鍵排序**。\n\n---\n\n## 1. 什麼時候用 `std::map`？\n- 需要 **自動排序** 與 **有序查找（lower/upper_bound）**。\n- 需要 **唯一鍵**，且常做範圍/邊界查詢。\n- 若只在意存在性/平均 O(1) 查找，不需順序 → `std::unordered_map`。\n- 若需要重複鍵 → `std::multimap`。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 排序準則：`Compare`（預設 `std::less<Key>`，遞增）。\n- 迭代器：`bidirectional`（可 ++、--）。\n- **元素鍵為 const**（`pair<const Key, T>`），不可直接修改鍵值。\n- 典型操作複雜度（N = size）：\n  - `insert / emplace / find / lower_bound / upper_bound`：`O(log N)`\n  - `erase(key)`：`O(log N)`；`erase(it)`：定位後攤銷 `O(1)`\n  - `operator[]`：`O(log N)`，必要時 **插入預設值**（有副作用！）\n- 迭代器失效：\n  - **插入**不會使其他 iterator 失效。\n  - **刪除**會使被刪元素的 iterator 失效，其餘不影響。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 建立 / 自訂比較器\n```cpp\n#include <map>\n#include <string>\nusing namespace std;\n\nstruct ByLenThenLex {\n    bool operator()(const string& a, const string& b) const {\n        if (a.size() != b.size()) return a.size() < b.size();\n        return a < b;\n    }\n};\n\nmap<int, string> m1 = {{2,\"two\"}, {1,\"one\"}};  // 依 key 排序 → (1,\"one\"), (2,\"two\")\nmap<string, int, ByLenThenLex> m2;             // 自訂排序\n```\n\n### 3.2 插入 / 查找 / 修改值\n```cpp\nmap<string, int> cnt;\n\ncnt[\"apple\"]++;                 // 若不存在會插入 (\"apple\", 0) 再 ++\nauto [it, inserted] = cnt.insert({\"banana\", 3});   // C++17 結構化綁定\ncnt.emplace(\"cherry\", 5);                           // 就地建構\n\nauto it2 = cnt.find(\"banana\");    // O(logN)；找不到回 end()\nbool has = cnt.count(\"apple\") > 0; // 或 C++20: cnt.contains(\"apple\")\n\nif (it2 != cnt.end()) it2->second += 10;  // 修改 value\n```\n\n### 3.3 不想插入就查值：`at` 與 `find`（避免 `operator[]` 副作用）\n```cpp\n// operator[] 會在不存在時插入 default(T)！查值時容易誤插入\nint x = cnt[\"not_exist\"];     // ⚠️ 插入 (\"not_exist\", 0)（若 T=int）\n\nauto it3 = cnt.find(\"not_exist\");     // 建議查找用 find/contains\nif (it3 != cnt.end()) {\n    int v = it3->second;\n}\n\nint v2 = cnt.at(\"apple\");             // 存在才回傳；否則丟出 out_of_range\n```\n\n### 3.4 C++17 便利 API：`try_emplace` / `insert_or_assign`\n```cpp\nmap<string, string> mp;\n\n// 只有在 key 不存在時才建構 value（避免無謂拷貝）\nmp.try_emplace(\"k\", 10, 'x'); // value 以 string(10,'x') 原地建構\n\n// 若存在則覆蓋，否則插入\nmp.insert_or_assign(\"k\", \"new_value\");\n```\n\n### 3.5 有序查找（lower/upper/equal_range）\n```cpp\nmap<int,string> m = {{2,\"b\"},{4,\"d\"},{6,\"f\"}};\n\nauto it = m.lower_bound(5);    // 第一個 key >= 5 → 指向 (6,\"f\")\nauto jt = m.upper_bound(4);    // 第一個 key > 4  → 指向 (6,\"f\")\nauto [l, r] = m.equal_range(4);// 介於 [4,4] 的範圍 → 單點或空\n```\n\n### 3.6 異質查找（Heterogeneous lookup, C++14/17 透明比較器）\n```cpp\n#include <string_view>\nmap<string, int, std::less<>> mp = {{\"alpha\",1},{\"beta\",2}};\nbool has = mp.contains(std::string_view(\"beta\")); // C++20 contains\nauto it  = mp.find(\"alpha\");                      // 直接用 const char* 查找\n```\n\n### 3.7 節點操作 `extract` / 容器合併 `merge`（C++17）\n```cpp\nmap<int,string> a = {{1,\"one\"},{3,\"three\"}};\nmap<int,string> b = {{2,\"two\"},{3,\"tres\"}};\n\nauto nh = a.extract(1);   // 取出 node_handle（鍵可讀，值可改）\nnh.key() == 1;            // 鍵是 const? 對 map：鍵讀不可改，但可搬移節點\nnh.mapped() = \"uno\";      // 可改 value\nb.insert(move(nh));       // 插入到 b\n\na.merge(b); // 將 b 中可插入的節點移入 a；衝突鍵留在 b\n```\n\n### 3.8 刪除與「邊迭代邊刪」\n```cpp\nfor (auto it = cnt.begin(); it != cnt.end(); ) {\n    if (it->second == 0) it = cnt.erase(it);  // C++11: erase(it) 回傳下一個\n    else ++it;\n}\n// 依 key 刪除：cnt.erase(\"apple\");   // 回傳刪除數量 0/1\n```\n\n---\n\n## 4. API 小抄（常用）\n- 構造：`map()` / `map(comp)` / `map(first,last,comp)` / `map(init_list,comp)`\n- 查找：`find(key)` / `count(key)` / **C++20** `contains(key)` / `lower_bound(key)` / `upper_bound(key)` / `equal_range(key)`\n- 存取：`operator[](key)` / `at(key)` / `at(key) const`\n- 插入：`insert(value)` / `insert(hint, value)` / `emplace(args...)` / `emplace_hint(hint,args...)` / **C++17** `try_emplace(key,args...)` / **C++17** `insert_or_assign(key,obj)`\n- 刪除：`erase(it)` / `erase(first,last)` / `erase(key)` / **C++20** `erase_if(map, pred)`（非成員）\n- 節點：**C++17** `extract(key/it)` / `merge(other)`（`node_type`）\n- 迭代：`begin()` / `end()` / `rbegin()` / `rend()` / `cbegin()` / `cend()`\n- 比較器與配接：`key_comp()` / `value_comp()` / `get_allocator()`\n\n---\n\n## 5. 常見坑與最佳實踐\n1. **`operator[]` 會插入**：查值時慎用，避免誤插入預設值；純查用 `find/contains/at`。\n2. **不能直接改鍵**：鍵是 const。若要變更鍵，考慮 `extract` 後改 `node` 再插回（或刪了重插）。\n3. **自訂比較器要嚴格弱序**：確保 `!(a<b) && !(b<a)` 表示等價，否則行為未定。\n4. **效能選擇**：需要 O(1) 平均查找就用 `unordered_map`；需要順序/邊界查找用 `map`。\n5. **異質查找**：用 `std::less<>` 作為透明比較器，避免臨時物件（如 `string_view`）。\n6. **大量插入**：可先收集後一次 `insert` 範圍或 `merge`；鍵接近有序時效率更好。\n7. **迭代器穩定**：插入不失效、刪除僅影響被刪元素，但**不要**在循環中無條件 `++it` 後又 `erase`。\n\n---\n\n## 6. 典型練習題型\n- 頻率統計（字數、元素出現次數）。\n- 區間/事件按鍵排序後的掃描、上/下界查找。\n- LRU/Cache 混合（`map` + `list`，或考慮 `ordered_map` 替代）。\n- 自訂排序的字串/結構體映射。\n\n---\n\n## 7. 迷你測試\n```cpp\nmap<int,string> m;\nm[10] = \"ten\";                   // 插入\nm.insert({5,\"five\"});\nm.try_emplace(7, 3, 'x');        // \"xxx\"\nm.insert_or_assign(10, \"TEN\");\n\nauto it = m.lower_bound(6);      // → key=7\nm.erase(5);                      // 刪 key=5\n\nfor (auto& [k,v] : m) { /* 有序輸出 */ }\n```\n\n---\n\n## 8. 備註\n- 多數實作為紅黑樹，保證 `O(logN)` 操作與有序迭代。\n- 舊編譯器可能不支援 C++20/23 API（如 `contains`、`erase_if`、`insert_range`）。\n"
  },
  {
    "id": "cpp-stl-set",
    "title": "STL set ",
    "category": "dataStructure",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/data-structures/cpp-stl-set.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-12-16",
    "markdownContent": "# STL set \n\n> 以 C++17/20 為基準，標註新版特性（C++17/20/23）。`std::set` 為 **有序、唯一鍵** 的關聯式容器，通常以 **紅黑樹** 實作。\n\n---\n\n## 1. 什麼時候用 `std::set`？\n- 需要 **自動排序**、**不允許重複**、**可做有序查找（lower/upper_bound）**。\n- 若只在意是否存在、且追求平均 O(1) 查找：考慮 `std::unordered_set`。\n- 若需要重複鍵：用 `std::multiset`。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 元素型別：`Key`（同時也是 value）。\n- 排序準則：`Compare`（預設 `std::less<Key>`，遞增）。\n- **唯一**：插入相同鍵會被忽略（或回報已存在）。\n- 迭代器：`bidirectional`（可 ++、--）。**元素為 const**（不能透過 iterator 改值）。\n- 主要操作複雜度（以 N = size）：\n  - `insert/emplace`：O(log N)\n  - `find/lower_bound/upper_bound`：O(log N)\n  - `erase(it)`：攤銷 O(1)（定位後刪除），`erase(key)`：O(log N)\n  - `merge`/`extract`：O(log N) 量級\n- 迭代器失效規則：\n  - **插入**不會使其他 iterator 失效。\n  - **刪除**會使被刪元素的 iterator 失效，其餘不受影響。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 建立 / 自訂比較器\n```cpp\n#include <set>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstruct ByLenThenLex {\n    bool operator()(const string& a, const string& b) const {\n        if (a.size() != b.size()) return a.size() < b.size();\n        return a < b;\n    }\n};\n\nint main() {\n    set<int> s1 = {3,1,2,2};      // 自動去重 → {1,2,3}\n\n    set<string, ByLenThenLex> s2 = {\"bb\", \"a\", \"aaa\", \"ab\"};\n    // 排序規則：長度優先，再字典序 → {\"a\",\"bb\",\"ab\",\"aaa\"}\n\n    for (auto& x : s1) cout << x << ' ';   // 1 2 3\n}\n```\n\n### 3.2 插入 / 查找 / 刪除\n```cpp\nset<int> s;\n\nauto [it, inserted] = s.insert(10); // C++17 結構化綁定；insert 回傳 pair<iterator,bool>\ns.emplace(7);                       // 原地構造（對複雜型別更省）\ns.insert({5, 8, 12});               // initializer_list\n\nbool has7 = s.count(7) > 0;         // 或 C++20: s.contains(7)\nauto it5 = s.find(5);               // O(logN)，找不到回 end()\n\ns.erase(8);                         // 依 key 刪除（回傳刪除數量 0/1）\nif (it5 != s.end()) s.erase(it5);   // 依 iterator 刪除，回傳下一個 iterator（C++11 起）\n```\n\n### 3.3 有序查找（lower/upper/equal_range）\n```cpp\nset<int> s = {2,4,6,8};\n\nauto it = s.lower_bound(5);   // 第一個 >= 5 → 指向 6\nauto jt = s.upper_bound(6);   // 第一個 > 6  → 指向 8\nauto [l, r] = s.equal_range(6); // [l,r) 為等於 6 的範圍（在 set 中要嘛 0 要嘛 1 個）\n```\n\n### 3.4 異質查找（Heterogeneous lookup, C++14/17 透明比較器）\n不必先建立臨時 `std::string`，可用 `string_view` 或 `char*` 查找：\n```cpp\n#include <string_view>\nset<string, std::less<>> s = {\"alpha\",\"beta\",\"gamma\"}; // 注意 std::less<> 透明比較器\nbool has = s.contains(std::string_view(\"beta\"));       // C++20 contains\nauto it  = s.find(\"gamma\");                            // 直接用 char const*\n```\n\n### 3.5 變更元素鍵值？用 `extract`（C++17）\n`set` 元素是 const，**不能**直接 `*it = newKey`。需 `extract` 節點、改值、再插回：\n```cpp\nset<int> s = {1,3,5};\nauto nh = s.extract(3);        // node_handle\nnh.value() = 4;                // 改鍵值\ns.insert(move(nh));            // 插回（會依排序就位）\n```\n\n### 3.6 容器合併 `merge`（C++17）\n將另一個 set 中“可插入”的節點移入本 set（不複製，節點搬移）：\n```cpp\nset<int> a = {1,3,5};\nset<int> b = {2,3,4};\na.merge(b); // a: {1,2,3,4,5}, b: {3}（因 3 已存在，b 中保留衝突者）\n```\n\n### 3.7 範圍插入（C++23 `insert_range`）\n```cpp\n// C++23\nvector<int> v = {7,1,9,4};\ns.insert_range(v);        // 等同於依序 insert v 中元素\n```\n\n---\n\n## 4. 小抄 API（常用）\n- 構造：`set<Key,Compare,Allocator>`、`set(first,last)`、`set(init_list)`\n- 基本：`size()` / `empty()` / `clear()` / `swap()`\n- 插入：`insert(value)` / `insert(hint, value)` / `insert({..})` / `emplace(args...)` / `emplace_hint(hint, args...)` / **C++23** `insert_range(range)`\n- 查找：`find(key)` / `count(key)` / **C++20** `contains(key)` / `lower_bound(key)` / `upper_bound(key)` / `equal_range(key)`\n- 刪除：`erase(it)` / `erase(first,last)` / `erase(key)`\n- 節點操作（C++17）：`extract(key/it)` / `merge(other)`（搭配 `node_type`）\n- 迭代：`begin()` / `end()` / `rbegin()` / `rend()` / `cbegin()` / `cend()`\n- 比較器：`key_comp()` / `value_comp()`\n- 配置器：`get_allocator()`\n\n---\n\n## 5. 常見坑與最佳實踐\n1. **不要改元素值**：iterator 取到的是 `const Key&`。要改鍵用 `extract`。\n2. **邊迭代邊刪除**：使用回傳 iterator 的 `erase(it)` 模式：\n   ```cpp\n   for (auto it = s.begin(); it != s.end(); ) {\n       if (條件) it = s.erase(it);   // 回傳下一個\n       else      ++it;\n   }\n   ```\n3. **效能選擇**：純查存在性且不需排序→ `unordered_set`；需要順序/界限查找→ `set`。\n4. **自訂比較器需「嚴格弱序」**：確保 `!(a<b) && !(b<a)` 才視為相等，避免未定義行為。\n5. **大量插入**：若來源已近似排序，插入成本更低；批量插入可先放容器再 `merge`/`insert_range`（C++23）。\n6. **異質查找**：用透明比較器 `std::less<>`，避免不必要的臨時物件。\n\n---\n\n## 6. 典型練習題型\n- 維護一組**已訪集合**、**唯一值集合**。\n- 動態集合中的**第 k 小**（`set` + 迭代器移動 / 或 `order_of_key` in PBDS）。\n- 線段切割、區間端點去重與排序（配合 `lower_bound`/`upper_bound`）。\n- 去重並按自訂規則排序字串 / 結構體（自訂比較器）。\n\n---\n\n## 7. 迷你測試\n```cpp\nset<int> s = {5,1,5,3};\nassert(s.size() == 3);                 // {1,3,5}\nassert(*s.begin() == 1);\nassert(*prev(s.end()) == 5);\n\nauto it = s.lower_bound(4);            // → 5\nassert(it != s.end() && *it == 5);\n\ns.erase(3);                             // {1,5}\nauto nh = s.extract(5); nh.value() = 4; s.insert(move(nh)); // {1,4}\nassert(s.count(4) == 1);\n```\n\n---\n\n## 8. 備註\n- 內部多以平衡 BST（紅黑樹）實作；不同標準庫可能細節不同，但複雜度保證一致。\n- 舊編譯器對某些 C++20/23 API（如 `contains`、`insert_range`）可能不支援。\n\n"
  },
  {
    "id": "cpp-stl-unordered-map",
    "title": "STL std::unordered_map 速查",
    "category": "dataStructure",
    "topics": [
      "C++",
      "STL",
      "HashMap",
      "Data Structures"
    ],
    "difficulty": "intermediate",
    "description": "雜湊表的關聯式容器，鍵唯一、平均 O(1) 查找，無序。",
    "contentPath": "/content/notes/data-structures/cpp-stl-unordered-map.md",
    "createdAt": "2025-10-05",
    "updatedAt": "2025-10-05",
    "markdownContent": "# STL `std::unordered_map` 中文速查（以實務使用為主）\n\n> 以 C++17/20/23 為基準。`std::unordered_map<Key,T,Hash,KeyEq>` 是 **雜湊表** 的關聯式容器：\n> - **鍵唯一**、**平均 O(1)** 插入/查找/刪除；最壞 O(N)（碰撞嚴重時）。\n> - **無序**（迭代次序不保證），適合「只管是否存在/取值」而不需排序的情境。\n\n---\n\n## 1. 什麼時候用 `unordered_map`？\n- 需要 **平均 O(1) 查找**，不在意有序遍歷。\n- 作為 **計數器 / 查表**（hash table）比 `std::map` 快。\n- 鍵可為自訂型別（需提供 `Hash` 與 `KeyEq`）。\n- 若要範圍查詢（lower/upper_bound）或固定有序輸出→改用 `std::map`。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 迭代器：`ForwardIterator`（只能 ++）。\n- 插入/查找/刪除：**平均 O(1)**；最壞 O(N)。\n- 重新雜湊（rehash）可能發生在：插入導致 **載入因子** 超過 `max_load_factor`。\n- **迭代器失效**：\n  - `rehash/ reserve`：**所有 iterators 失效**。\n  - `erase`：被刪的元素迭代器失效，其餘保持有效。\n  - 參考/指標：重雜湊通常 **不會** 使其失效（除非該元素被刪）。\n- 桶與負載：`bucket_count()`、`load_factor()`、`max_load_factor()`、`rehash(n)`、`reserve(n)`。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 基本增查改刪\n```cpp\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nunordered_map<string, int> freq;\n\nfreq[\"apple\"]++;                            // 若無則插入 (\"apple\",0) 再 ++\nauto [it, inserted] = freq.insert({\"a\", 1}); // C++17 結構化綁定\nfreq.emplace(\"b\", 2);                        // 原地建構\nfreq.insert_or_assign(\"b\", 5);               // 存在則賦值，不在則插入（C++17）\n\nauto it2 = freq.find(\"apple\");               // 平均 O(1)，找不到回 end()\nbool has = freq.count(\"banana\") > 0;         // C++20: freq.contains(\"banana\")\n\nif (it2 != freq.end()) it2->second += 10;    // 修改 value\nfreq.erase(\"a\");                              // 依 key 刪\n```\n\n### 3.2 預先保留容量、控制 rehash\n```cpp\nunordered_map<int, int> mp;\nmp.reserve(100000);               // 預留桶數以容納大概元素數（減少 rehash 次數）\nmp.max_load_factor(1.0f);         // 每桶平均允許的元素數（預設 ~1）\n```\n\n### 3.3 自訂雜湊與相等（自訂型別）\n```cpp\nstruct Point { int x, y; };\n\nstruct PointHash {\n    size_t operator()(const Point& p) const noexcept {\n        // 混合 x,y；簡化示例，實務可用更好的 hash 混合\n        return (std::hash<int>{}(p.x) * 1315423911u) ^ std::hash<int>{}(p.y);\n    }\n};\nstruct PointEq {\n    bool operator()(const Point& a, const Point& b) const noexcept {\n        return a.x == b.x && a.y == b.y;\n    }\n};\n\nunordered_map<Point, int, PointHash, PointEq> mp;\nmp[{3,4}] = 7;\n```\n\n### 3.4 異質查找（Heterogeneous lookup, **需要透明 hash/equal**）\n> 若提供的 `Hash` 和 `KeyEq` **支持透明比較**（C++20 常見模式：為它們提供 `is_transparent`），即可用相容鍵型別查找而不建臨時 Key。這通常需要**自訂** Hash/KeyEq；標準的 `std::hash<Key>` 本身不一定透明。\n```cpp\n// 伪碼/示意：Hash/KeyEq 需定義 is_transparent 並支援 string_view/const char* 等\nstruct TransparentHash { using is_transparent = void; /* ... */ };\nstruct TransparentEq   { using is_transparent = void; /* ... */ };\n\nunordered_map<string, int, TransparentHash, TransparentEq> mp2;\nbool ok = mp2.contains(std::string_view(\"hello\"));\n```\n\n### 3.5 節點與合併（C++17）\n```cpp\nunordered_map<int,string> a = {{1,\"one\"},{3,\"three\"}};\nunordered_map<int,string> b = {{2,\"two\"},{3,\"tres\"}};\n\nauto nh = a.extract(1);        // 取出 node_handle（鍵可讀，值可改）\nnh.mapped() = \"uno\";           // 改 value\nb.insert(move(nh));            // 插入到 b\n\na.merge(b);                    // 把 b 中可插入的節點搬到 a；衝突鍵留在 b\n```\n\n### 3.6 「邊迭代邊刪除」\n```cpp\nfor (auto it = freq.begin(); it != freq.end(); ) {\n    if (it->second == 0) it = freq.erase(it); // erase 回傳下一個 iterator\n    else ++it;\n}\n```\n\n---\n\n## 4. API 小抄（常用）\n- 構造：`unordered_map()` / `unordered_map(bucket_count)` / `unordered_map(first,last)` / `unordered_map(init_list)`\n- 查找：`find(key)` / `count(key)` / **C++20** `contains(key)`\n- 存取：`operator[](key)` / `at(key)` / `at(key) const`\n- 插入：`insert(value)` / `insert(hint,value)` / `insert(init_list)` / `emplace(args...)` / `try_emplace(key,args...)` / `insert_or_assign(key,obj)`\n- 刪除：`erase(it)` / `erase(first,last)` / `erase(key)` / **C++20** `erase_if(map, pred)`（非成員）\n- 桶與 rehash：`bucket_count()` / `bucket(key)` / `load_factor()` / `max_load_factor()` / `rehash(n)` / `reserve(n)` / `begin(n), end(n)`（桶級迭代）\n- 節點：**C++17** `extract(key/it)` / `merge(other)`（`node_type`）\n- 迭代：`begin()` / `end()` / `cbegin()` / `cend()`（次序不保證，且 rehash 會改變）\n\n---\n\n## 5. 常見坑與最佳實踐\n1. **rehash 會使所有 iterators 失效**：\n   - 在保留指標/iterator 之後 `insert` 可能觸發 rehash，導致失效。\n   - 若需要穩定：先 `reserve()` 足夠容量，或用 `std::map`。\n2. **`operator[]` 會插入預設值**：僅查值請用 `find/contains/at`，避免誤插。\n3. **鍵的 hash/equal 必須相容**：兩者的「相等」要對應到同樣的 hash 值域，否則行為退化或錯誤。\n4. **迭代次序不固定**：不要依賴輸出順序；若要排序輸出，拷貝鍵到 `vector` 後排序。\n5. **大量插入**：先 `reserve(N)`，減少 rehash 次數。\n6. **自訂型別 hash**：確保雜湊分布良好，避免碰撞造成性能下降。\n7. **異質查找**：需要自訂透明 Hash/KeyEq，否則預設不一定支援。\n\n---\n\n## 6. 典型練習題型\n- 次數統計（字頻、元素頻率）。\n- LRU/Cache 的 key→node 映射（通常配合 list）。\n- 兩數和/子陣列和等「查表」型解法。\n- 去重與存在性檢查（搭配 `unordered_set`）。\n\n---\n\n## 7. 迷你測試\n```cpp\nunordered_map<string,int> m;\nm.reserve(8);\nm[\"a\"] = 1; m[\"b\"] = 2; m[\"c\"] = 3;\n\nauto it = m.find(\"b\");\nif (it != m.end()) it->second += 10;\n\nm.erase(\"a\");\nfor (auto& [k,v] : m) { /* 無序輸出 */ }\n\n// 測 rehash 失效\nauto it2 = m.begin();\nm.insert({\"x\", 42});    // 可能 rehash\n// it2 可能失效，避免繼續使用\n```\n\n---\n\n## 8. 備註\n- 大部分實作採 **分離鏈結法（chaining）**：每個桶是一條鏈或小向量。\n- C++ 標準不保證 hash 分布與 rehash 策略，但提供負載因子介面讓你調整。\n- 舊編譯器對 C++20/23 的 `contains`、`erase_if` 等 API 支援度不一。\n\n"
  },
  {
    "id": "cpp-stl-unordered-set",
    "title": "STL std::unordered_set 速查",
    "category": "dataStructure",
    "topics": [
      "C++",
      "STL",
      "HashSet",
      "Data Structures"
    ],
    "difficulty": "intermediate",
    "description": "雜湊表的集合容器，元素唯一、平均 O(1) 查找，無序。",
    "contentPath": "/content/notes/data-structures/cpp-stl-unordered-set.md",
    "createdAt": "2025-10-05",
    "updatedAt": "2025-10-05",
    "markdownContent": "# STL `std::unordered_set` 中文速查（以實務使用為主）\n\n> 以 C++17/20/23 為基準。`std::unordered_set<T, Hash, KeyEq>` 是 **雜湊表** 的集合容器：\n> - **元素唯一**、**平均 O(1)** 插入/查找/刪除；最壞 O(N)（碰撞嚴重）。\n> - **無序**（迭代次序不保證），適合做「存在性檢查／去重」與快速查找。\n\n---\n\n## 1. 什麼時候用 `unordered_set`？\n- 只在意「是否存在」或需要 **平均 O(1) 查找**。\n- 要快速去重、記錄 visited、做 membership 查詢。\n- 若需要 **排序／有序遍歷／下界查找** → 用 `std::set`。\n- 若需要記錄次數（鍵→值） → 用 `std::unordered_map`。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 迭代器：`ForwardIterator`（只能 ++）。\n- 插入/查找/刪除：**平均 O(1)**；碰撞嚴重時最壞 O(N)。\n- **rehash**（重雜湊）在桶數不足時發生，會：\n  - 使 **所有 iterators 失效**。\n  - 通常 **不會** 使指向元素的參考/指標失效（除非元素被刪）。\n- 容量與負載：`bucket_count()`、`load_factor()`、`max_load_factor()`、`rehash(n)`、`reserve(n)`。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 基本增查刪\n```cpp\n#include <unordered_set>\nusing namespace std;\n\nunordered_set<int> s;\n\nauto [it, inserted] = s.insert(10);    // C++17 結構化綁定\ns.emplace(7);                           // 原地建構（對複雜型別更省）\ns.insert({5, 8, 12});                   // initializer_list\n\nbool has7 = s.count(7) > 0;             // C++20: s.contains(7)\nauto it5 = s.find(5);                   // 平均 O(1)，找不到回 end()\n\ns.erase(8);                             // 依 key 刪除（回傳刪除數量 0/1）\nif (it5 != s.end()) s.erase(it5);       // 依 iterator 刪除，回傳下一個 iterator\n```\n\n### 3.2 預留容量／控制 rehash\n```cpp\nunordered_set<string> st;\nst.reserve(100000);            // 減少 rehash 次數\nst.max_load_factor(1.0f);      // 每桶平均允許元素數（預設約 1.0）\n```\n\n### 3.3 自訂雜湊與相等（自訂型別）\n```cpp\nstruct Point { int x, y; };\n\nstruct PointHash {\n    size_t operator()(const Point& p) const noexcept {\n        return (hash<int>{}(p.x) * 1315423911u) ^ hash<int>{}(p.y);\n    }\n};\nstruct PointEq {\n    bool operator()(const Point& a, const Point& b) const noexcept {\n        return a.x == b.x && a.y == b.y;\n    }\n};\n\nunordered_set<Point, PointHash, PointEq> ps;\nps.insert({3,4});\n```\n\n### 3.4 異質查找（Heterogeneous lookup，需透明 Hash/KeyEq）\n> 若 Hash/KeyEq 提供 `is_transparent` 並支援相容鍵型別，可避免建立臨時物件。\n```cpp\n// 示意：為 Hash/KeyEq 定義 using is_transparent = void;\nstruct TransparentHash { using is_transparent = void; /* ... */ };\nstruct TransparentEq   { using is_transparent = void; /* ... */ };\n\nunordered_set<string, TransparentHash, TransparentEq> st2;\nbool ok = st2.contains(std::string_view(\"hello\")); // C++20 contains\nauto it = st2.find(\"hello\");                       // 直接用 const char*\n```\n\n### 3.5 「邊迭代邊刪除」\n```cpp\nfor (auto it = s.begin(); it != s.end(); ) {\n    if (*it % 2 == 0) it = s.erase(it);  // erase 回傳下一個 iterator\n    else ++it;\n}\n```\n\n---\n\n## 4. API 小抄（常用）\n- 構造：`unordered_set()` / `unordered_set(bucket_count)` / `unordered_set(first,last)` / `unordered_set(init_list)`\n- 查找：`find(key)` / `count(key)` / **C++20** `contains(key)`\n- 插入：`insert(value)` / `insert(hint,value)` / `insert(init_list)` / `emplace(args...)`\n- 刪除：`erase(it)` / `erase(first,last)` / `erase(key)` / **C++20** `erase_if(set, pred)`（非成員）\n- 桶與 rehash：`bucket_count()` / `bucket(key)` / `load_factor()` / `max_load_factor()` / `rehash(n)` / `reserve(n)` / `begin(n), end(n)`（桶級迭代）\n- 迭代：`begin()` / `end()` / `cbegin()` / `cend()`（次序不保證，rehash 會改變）\n\n---\n\n## 5. 常見坑與最佳實踐\n1. **rehash 使所有 iterators 失效**：在保存 iterator 後進行插入可能觸發 rehash，請先 `reserve()`。\n2. **不要依賴迭代順序**：`unordered_set` 無序；若要排序輸出，拷貝到 `vector` 後 `sort`。\n3. **良好的雜湊與相等比較**：確保 `Hash` 與 `KeyEq` 一致且分布良好；碰撞多會降速。\n4. **大量插入**：預先 `reserve(N)`；適度調整 `max_load_factor()`。\n5. **異質查找**：需要自訂透明 Hash/KeyEq 才能用 `string_view`/`char*` 等相容鍵。\n6. **元素是唯一的**：若需要重複元素 → 請用 `unordered_multiset`。\n\n---\n\n## 6. 典型練習題型\n- 去重與存在性檢查（Two Sum 的輔助集合、子陣列和去重）。\n- 記錄 visited（BFS/DFS 狀態集合）。\n- 快速判斷字元/字串集合包含關係。\n- 流式資料的唯一元素統計（搭配 `unordered_map` 追數量）。\n\n---\n\n## 7. 迷你測試\n```cpp\nunordered_set<int> s = {1,2,3,2};\nassert(s.size() == 3);\n\nauto it = s.find(2);\nif (it != s.end()) s.erase(it);\ns.insert(100);\n\nsize_t b = s.bucket(100);           // 100 所在桶索引\nfloat lf = s.load_factor();         // 當前負載\ns.rehash(128);                      // 重雜湊到至少 128 桶（迭代器失效！）\n```\n\n---\n\n## 8. 與 `std::set` 對照（簡表）\n| 面向 | `unordered_set` | `set` |\n|---|---|---|\n| 存取複雜度 | 平均 O(1)，最壞 O(N) | O(log N) |\n| 是否有序 | 否 | 是（依 Compare 排序） |\n| 邊界查找 | 不支援 lower/upper_bound | 支援 |\n| 迭代器 | Forward（只能 ++） | Bidirectional（可 ++/--） |\n| 迭代穩定 | rehash 使所有 iterators 失效 | 插入不失效，刪除僅影響被刪元素 |\n\n---\n\n## 9. 備註\n- 常見實作為 **分離鏈結法（chaining）**：每桶是一條鏈或小陣列。\n- C++ 標準不保證 rehash 策略；透過 `reserve / max_load_factor` 可影響行為。\n- 老舊編譯器對 C++20/23 API（如 `contains`、`erase_if`）支援度不一。\n\n"
  },
  {
    "id": "cpp-stl-vector",
    "title": "STL std::vector 速查",
    "category": "dataStructure",
    "topics": [
      "C++",
      "STL",
      "Vector",
      "Data Structures"
    ],
    "difficulty": "beginner",
    "description": "連續記憶體的序列容器，支援動態擴張、隨機存取 O(1)，是最常用的容器。",
    "contentPath": "/content/notes/data-structures/cpp-stl-vector.md",
    "createdAt": "2025-10-05",
    "updatedAt": "2025-10-05",
    "markdownContent": "# STL `std::vector` 中文速查（以實務使用為主）\n\n> 以 C++17/20/23 為基準。`std::vector<T>` 是 **連續記憶體（contiguous）** 的序列容器，支援動態擴張、隨機存取（`O(1)`），是最常用的容器。\n\n---\n\n## 1. 什麼時候用 `std::vector`？\n- 需要 **連續記憶體**（與 C 陣列/第三方 API 互通、可用 `&v[0]` / `v.data()`）。\n- **隨機存取 O(1)**、尾端插入/刪除 `push_back/pop_back` 高效（均攤 amortized `O(1)`）。\n- 元素數量會動態變化，但主要在**尾端**變動。若中間頻繁插入/刪除，改用 `std::list`/`deque` 或其他結構。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 迭代器：`random access`。\n- 記憶體：連續配置；**成長時可能重新配置（reallocate）** → 使 **所有 iterator/指標/參考失效**。\n- 主要操作（N = size）\n  - `operator[] / at()`：`O(1)`（`at()`含界限檢查）。\n  - `push_back / emplace_back`：均攤 `O(1)`；成長觸發 reallocate 時為 `O(N)`。\n  - `insert / erase`（非尾端）：`O(N)`（因為需要搬移元素）。\n  - `resize / assign`：`O(N)`（根據新元素建構/拷貝成本）。\n- 容量管理\n  - `size()`：目前元素個數。\n  - `capacity()`：已配置容量（≥ size）。\n  - `reserve(n)`：至少預留容量 n（不改 size）。\n  - `shrink_to_fit()`：**非強制**請求釋放多餘容量（是否真的縮小取決於實作）。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 建立 / 初始化\n```cpp\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    vector<int> a;                 // 空\n    vector<int> b(5);              // 5 個 0\n    vector<int> c(3, 7);           // 3 個 7\n    vector<int> d = {1,2,3};       // init-list\n\n    cout << d.size() << \" \" << d.capacity() << \"\\n\";\n}\n```\n\n### 3.2 讀寫與邊界\n```cpp\nvector<int> v = {10,20,30};\nint x = v[1];         // 20 (無界限檢查)\nint y = v.at(1);      // 20 (有界限檢查，越界拋例外)\nv[2] = 99;\n```\n\n### 3.3 追加 / 擴張 / 縮小\n```cpp\nvector<string> names;\nnames.reserve(1000);              // 預留容量，避免多次重配\nnames.push_back(\"alice\");\nnames.emplace_back(10, 'x');      // 直接建構 \"xxxxxxxxxx\"\n\nnames.resize(5);                  // 若擴大 → 以 T() 填充；若縮小 → 呼叫析構\nnames.resize(7, \"pad\");           // 擴大時以 \"pad\" 填充\nnames.shrink_to_fit();            // 可能縮減容量（非保證）\n```\n\n### 3.4 插入 / 刪除（中間位置）\n```cpp\nvector<int> v = {1,2,3,4};\nv.insert(v.begin()+2, 7);         // {1,2,7,3,4}\nv.erase(v.begin()+1);             // {1,7,3,4}\nv.erase(v.begin()+1, v.begin()+3);// {1,4}  刪掉 [1,3) 範圍\n```\n\n### 3.5 迭代與「邊迭代邊刪除」\n```cpp\nfor (auto it = v.begin(); it != v.end(); ) {\n    if (*it % 2 == 0) it = v.erase(it);   // erase 會回傳下一個 iterator\n    else ++it;\n}\n```\n\n### 3.6 erase-remove 惯用法（刪除符合條件的所有元素）\n```cpp\nvector<int> v = {1,2,3,2,4};\nv.erase(remove(v.begin(), v.end(), 2), v.end());  // 移除所有 2\n// 若要自訂條件：remove_if(v.begin(), v.end(), pred)\n```\n\n### 3.7 取得底層指標\n```cpp\nvector<double> buf = {1.0, 2.0, 3.0};\ndouble* p = buf.data();           // 或 &buf[0]（非空時）\n```\n\n### 3.8 二維 vector\n```cpp\nint n=3,m=4;\nvector<vector<int>> g(n, vector<int>(m, 0));\ng[1][2] = 7;\n```\n\n---\n\n## 4. API 小抄（常用）\n- 構造：`vector()` / `vector(n)` / `vector(n, val)` / `vector(first,last)` / `vector(init_list)`\n- 取值：`operator[]` / `at()` / `front()` / `back()` / `data()`\n- 容量：`size()` / `empty()` / `capacity()` / `reserve(n)` / `shrink_to_fit()`\n- 修改：\n  - 追加：`push_back()` / `emplace_back()` / `append_range(r)`（C++23）\n  - 指定：`assign(n,val)` / `assign(first,last)` / `assign(init_list)`\n  - 插入：`insert(pos, val/count/first,last/init_list)` / `emplace(pos, args...)`\n  - 擴縮：`resize(n)` / `resize(n,val)` / `clear()` / `erase(pos)` / `erase(first,last)` / `swap()`\n- 迭代：`begin()` / `end()` / `rbegin()` / `rend()` / `cbegin()` / `cend()`\n\n> **C++23** `append_range(r)`：將 range 內容追加到尾端（部分實作尚未支援）。\n\n---\n\n## 5. 重要語義與陷阱\n1. **重新配置（reallocation）會使** `迭代器 / 指標 / 參考` **全部失效**：  \n   - 任何 `push_back / insert` 造成容量成長都可能重配。  \n   - 若要維持指標有效：先 `reserve()` 足夠容量。\n2. **`vector<bool>` 特例**：位壓縮的 proxy 型別，不是一般 reference；避免把它當 `bool*` 使用。\n3. **插入/刪除中間元素成本高**：`O(N)` 搬移。若需求頻繁，考慮 `deque`/`list`/其他結構。\n4. **`shrink_to_fit()` 非保證**：是「請求」，可能無效。\n5. **越界存取**：`operator[]` 不檢查界限；需要檢查用 `at()`。\n6. **自訂型別**：大量擴張/搬移會觸發拷貝/移動建構，注意成本；可提供移動建構最佳化。\n7. **與 C API 互通**：用 `data()` 暴露連續記憶體；確保容量足夠避免重配時指標失效。\n\n---\n\n## 6. 效能建議\n- **已知近似大小**：先 `reserve(N)` 減少重配次數。\n- **大量追加**：優先 `emplace_back`（省一次臨時物件）。\n- **批次插入**：`insert(end(), first, last)` 比逐一 `push_back` 更快（實作可能一次擴容）。\n- **避免頻繁縮擴**：預估容量、合併操作，最後再 `shrink_to_fit()`。\n\n---\n\n## 7. 典型練習題型\n- 動態收集結果（例如 backtracking 產生的解集合）。\n- 前綴和、DP 表（連續記憶體有利於快取）。\n- 排序 + 去重（`sort` + `erase(unique(...))`）。\n- 以 `vector<pair/...>>` 儲存圖邊、事件清單等結構。\n\n---\n\n## 8. 迷你測試\n```cpp\nvector<int> v; \nv.reserve(4);\nfor (int i=1;i<=4;++i) v.push_back(i);     // [1,2,3,4]\nauto p = v.data();\nv.push_back(5);                             // 可能 reallocate → p 失效\nv.erase(remove(v.begin(), v.end(), 3), v.end()); // [1,2,4,5]\n```\n\n---\n\n## 9. 備註\n- 多數實作採「倍增」策略擴容（如 x2），但標準未固定策略。  \n- 連續性保證：`&v[i] + 1 == &v[i+1]`。可與 `memcpy`/C API 互通（對 trivially copyable 類型）。\n"
  },
  {
    "id": "dsu_disjoint_set_union",
    "title": "Disjoint Set Union（DSU / Union-Find）筆記",
    "category": "dataStructure",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/data-structures/dsu_disjoint_set_union.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-12-16",
    "markdownContent": "# Disjoint Set Union（DSU / Union-Find）筆記\n\n---\n\n## 一、DSU 是什麼？\n\n**Disjoint Set Union（不相交集合）** 是一種資料結構，用來動態維護：\n\n- 多個「互不重疊的集合」\n- 支援快速查詢：\n  - 兩個元素是否屬於同一個集合\n  - 合併兩個集合\n\n在圖論中非常常見，特別是：\n\n- **Minimum Spanning Tree（Kruskal）**\n- Connected Components\n- Cycle detection\n\n---\n\n## 二、核心操作\n\nDSU 只做兩件事：\n\n### 1️⃣ Find(x)\n\n> 找出元素 `x` 所屬集合的「代表元素（root）」\n\n性質：\n- 同一集合中的所有元素，Find 出來的 root 相同\n\n### 2️⃣ Union(x, y)\n\n> 合併 `x` 與 `y` 所屬的兩個集合（若不同）\n\n---\n\n## 三、資料結構設計\n\n### 基本版本（parent array）\n\n- `parent[x] = x`：x 是集合代表\n- `parent[x] = y`：x 的父節點是 y\n\n每個集合實際上是一棵樹，root 是代表元素。\n\n---\n\n## 四、兩個關鍵優化（一定要會）\n\n### ✅ 1. Path Compression（路徑壓縮）\n\n在 `Find(x)` 時：\n\n- 把 x 到 root 的整條路徑，直接接到 root\n- 讓之後查詢幾乎是 O(1)\n\n```cpp\nint Find(int x) {\n    if (parent[x] != x)\n        parent[x] = Find(parent[x]);\n    return parent[x];\n}\n```\n\n---\n\n### ✅ 2. Union by Size / Rank（依大小或高度合併）\n\n想法：\n- 永遠讓「小樹接到大樹」\n- 避免樹退化成鏈\n\n---\n\n## 五、標準 C++ DSU 模板（推薦）\n\n```cpp\nstruct DSU {\n    vector<int> parent, size;\n\n    DSU(int n) {\n        parent.resize(n);\n        size.assign(n, 1);\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int Find(int x) {\n        if (parent[x] != x)\n            parent[x] = Find(parent[x]);\n        return parent[x];\n    }\n\n    // return true if merged, false if already same set\n    bool Union(int a, int b) {\n        a = Find(a);\n        b = Find(b);\n        if (a == b) return false;\n        if (size[a] < size[b]) swap(a, b);\n        parent[b] = a;\n        size[a] += size[b];\n        return true;\n    }\n};\n```\n\n📌 **時間複雜度**：\n- 單次操作：\\( \\alpha(n) \\)（反 Ackermann，幾乎常數）\n\n---\n\n## 六、DSU 在 Kruskal 中的角色\n\nKruskal 核心流程：\n\n1. 把所有邊依權重排序\n2. 依序嘗試加入邊 (u, v)\n3. 若 `Find(u) != Find(v)`：\n   - 不會形成 cycle\n   - 可以加入 MST\n   - 執行 `Union(u, v)`\n\n### 為什麼 DSU 能避免 cycle？\n\n- 若 u 和 v 已在同一集合\n- 代表 MST 中已經有一條路徑連到\n- 再加會形成環\n\n---\n\n## 七、常見錯誤整理\n\n❌ 忘記初始化 parent\n\n❌ Find 沒做 path compression（TLE 高機率）\n\n❌ Union 沒做 size / rank 合併\n\n❌ 在 Kruskal 中沒檢查 `Find(u) != Find(v)`\n\n---\n\n## 八、你現在應該能做到的事\n\n- 手寫 DSU 模板（不用背，用理解）\n- 解釋為什麼 Kruskal 正確\n- 清楚 DSU 為什麼近似 O(1)\n\n---\n\n## 九、延伸練習（推薦）\n\n- LeetCode 547 – Number of Provinces\n- LeetCode 684 – Redundant Connection\n- LeetCode 1584 – Min Cost to Connect All Points\n\n---\n\n（完）\n\n"
  },
  {
    "id": "trie",
    "title": "Trie（前綴樹）完整筆記 — 概念、實作、用途與題型",
    "category": "dataStructure",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/data-structures/trie.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-12-16",
    "markdownContent": "> **適合對象**：零基礎～入門程度，想理解「Trie（前綴樹）」是什麼、怎麼實作、何時使用。  \n> **你會學到**：Trie 的核心概念、時間與空間複雜度、實作（C++ 與 Python 版本）、常見坑、延伸變體、典型題目清單。\n\n---\n\n# 1. 什麼是 Trie？（用生活比喻）\nTrie（讀音類似「try」），中文常譯「字典樹／前綴樹」。它把很多**字串**存成一棵樹：  \n- 從根節點出發，每條邊代表**一個字元**；  \n- 一條從根到某個節點的路徑，對應一個**前綴（prefix）**；  \n- 若某個節點被標記為「字尾」，表示**有字串在此結束**。\n\n**比喻**：像電話語音系統「請輸入區碼…」：你每按下一個數字，就走下一層分支。某條完整路徑對應一個完整號碼。\n\n---\n\n# 2. 為什麼用 Trie？（適用場景）\n- **大量字串查詢**：要快速判斷「某字是否存在」、「是否有以某前綴開頭的字」。  \n- **自動補完（Autocomplete）／拼字檢查（Spell Check）**：根據目前輸入的前綴，快速列出候選字。  \n- **統計**：統計某前綴出現次數、統計某字串被插入幾次。  \n- **壓縮共用前綴**：相同開頭只存一次，大幅減少重複儲存。\n\n> 與 **Hash（雜湊）** 比較：Hash 查整字很快，但對「前綴」問題做不到自然支援；Trie 對前綴類查詢非常友善。\n\n---\n\n# 3. 基本操作與複雜度\n假設字元集是小寫英文字母 a–z（26 個）。\n\n- `insert(word)`：逐字走下去，若沒有節點就新建，最後節點標記「是單字結尾」。  \n  - 時間：`O(L)`（L=字長），空間：每個新字母需要新節點（最壞 `O(總字元數)`).  \n- `search(word)`：逐字走下去，若中途缺節點→不存在；走完且結尾標記為真→存在。  \n  - 時間：`O(L)`。  \n- `startsWith(prefix)`：逐字走到 prefix 尾即可，無需結尾標記。  \n  - 時間：`O(P)`（P=前綴長度）。  \n- `erase(word)`（刪除一個字）：把該字的計數減一，必要時回收不再使用的節點。  \n  - 時間：`O(L)`。\n\n> **統計擴充**：在每個節點維護：  \n> - `pass`：有多少字通過這個節點（含結尾在更深處的字）；  \n> - `end`：有多少字在此結尾。  \n> 可支援函式：`countWordsEqualTo(word)`、`countWordsStartingWith(prefix)`。\n\n---\n\n# 4. 視覺化例子（ASCII 圖）\n插入 `[\"to\", \"tea\", \"ted\", \"ten\", \"A\", \"inn\"]`（假設只考慮英文大小寫作為示例）：\n\n```\n(root)\n ├── 'A' (end=1)\n └── 't'\n     └── 'e'\n     │     ├── 'a' (end=1)  → \"tea\"\n     │     ├── 'd' (end=1)  → \"ted\"\n     │     └── 'n' (end=1)  → \"ten\"\n     └── 'o' (end=1)        → \"to\"\n```\n- `\"te\"` 是前綴，但只有當 `end>0` 才代表完整單字。\n\n---\n\n# 5. C++17 實作（英文字母 a–z）\n> 若你的字元集更大（含大小寫、數字、Unicode），請看下方「擴展與進階」。\n\n## 5.1 節點設計（陣列寫法）\n- 使用固定大小 `children[26]` 指向子節點（更快、少額外配置）。  \n- 用 `pass`、`end` 做計數擴充，支援統計與安全刪除。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TrieNode {\n    TrieNode* child[26];\n    int pass; // 經過此節點的字串數\n    int end;  // 在此結點結尾的字串數\n\n    TrieNode() : pass(0), end(0) {\n        memset(child, 0, sizeof(child));\n    }\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n\n    void freeSubtree(TrieNode* node) {\n        if (!node) return;\n        for (int i = 0; i < 26; ++i) {\n            if (node->child[i]) freeSubtree(node->child[i]);\n        }\n        delete node;\n    }\n\npublic:\n    Trie() { root = new TrieNode(); }\n    ~Trie() { freeSubtree(root); }\n\n    void insert(const string& word) {\n        TrieNode* cur = root;\n        cur->pass++;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            if (!cur->child[idx]) cur->child[idx] = new TrieNode();\n            cur = cur->child[idx];\n            cur->pass++;\n        }\n        cur->end++;\n    }\n\n    bool search(const string& word) const {\n        const TrieNode* cur = root;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            if (!cur->child[idx]) return false;\n            cur = cur->child[idx];\n        }\n        return cur->end > 0;\n    }\n\n    bool startsWith(const string& prefix) const {\n        const TrieNode* cur = root;\n        for (char ch : prefix) {\n            int idx = ch - 'a';\n            if (!cur->child[idx]) return false;\n            cur = cur->child[idx];\n        }\n        return true;\n    }\n\n    int countWordsEqualTo(const string& word) const {\n        const TrieNode* cur = root;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            if (!cur->child[idx]) return 0;\n            cur = cur->child[idx];\n        }\n        return cur->end;\n    }\n\n    int countWordsStartingWith(const string& prefix) const {\n        const TrieNode* cur = root;\n        for (char ch : prefix) {\n            int idx = ch - 'a';\n            if (!cur->child[idx]) return 0;\n            cur = cur->child[idx];\n        }\n        return cur->pass;\n    }\n\n    bool erase(const string& word) {\n        // 先確認存在\n        TrieNode* cur = root;\n        vector<pair<TrieNode*, int>> stk;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            if (!cur->child[idx] || cur->child[idx]->pass == 0) return false;\n            stk.push_back({cur, idx});\n            cur = cur->child[idx];\n        }\n        if (cur->end == 0) return false;\n\n        // 實際刪除：end--，沿路 pass--，如 pass=0 釋放子樹\n        cur->end--;\n        cur = root;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            TrieNode* nxt = cur->child[idx];\n            nxt->pass--;\n            if (nxt->pass == 0) {\n                freeSubtree(nxt);\n                cur->child[idx] = nullptr;\n                break;\n            }\n            cur = nxt;\n        }\n        return true;\n    }\n};\n```\n\n### 使用範例\n```cpp\nint main() {\n    Trie trie;\n    trie.insert(\"apple\");\n    trie.insert(\"app\");\n    trie.insert(\"apple\");\n\n    cout << boolalpha;\n    cout << trie.search(\"apple\") << \"\\n\";     // true\n    cout << trie.search(\"appl\") << \"\\n\";      // false\n    cout << trie.startsWith(\"ap\") << \"\\n\";    // true\n    cout << trie.countWordsEqualTo(\"apple\") << \"\\n\";       // 2\n    cout << trie.countWordsStartingWith(\"app\") << \"\\n\";    // 3\n    cout << trie.erase(\"apple\") << \"\\n\";                   // true\n    cout << trie.countWordsEqualTo(\"apple\") << \"\\n\";       // 1\n    cout << trie.erase(\"banana\") << \"\\n\";                  // false\n}\n```\n\n---\n\n## 5.2 map/unordered_map 寫法（支援更大字元集）\n```cpp\nstruct Node {\n    unordered_map<char, Node*> next;\n    int pass = 0, end = 0;\n    ~Node() {\n        for (auto &kv : next) delete kv.second;\n    }\n};\n\nclass Trie2 {\n    Node* root;\npublic:\n    Trie2(): root(new Node()) {}\n    ~Trie2(){ delete root; }\n\n    void insert(const string& s) {\n        Node* cur = root;\n        cur->pass++;\n        for (char c : s) {\n            if (!cur->next.count(c)) cur->next[c] = new Node();\n            cur = cur->next[c];\n            cur->pass++;\n        }\n        cur->end++;\n    }\n\n    bool search(const string& s) const {\n        const Node* cur = root;\n        for (char c : s) {\n            auto it = cur->next.find(c);\n            if (it == cur->next.end()) return false;\n            cur = it->second;\n        }\n        return cur->end > 0;\n    }\n\n    bool startsWith(const string& pre) const {\n        const Node* cur = root;\n        for (char c : pre) {\n            auto it = cur->next.find(c);\n            if (it == cur->next.end()) return false;\n            cur = it->second;\n        }\n        return true;\n    }\n\n    int countWordsEqualTo(const string& s) const {\n        const Node* cur = root;\n        for (char c : s) {\n            auto it = cur->next.find(c);\n            if (it == cur->next.end()) return 0;\n            cur = it->second;\n        }\n        return cur->end;\n    }\n\n    int countWordsStartingWith(const string& pre) const {\n        const Node* cur = root;\n        for (char c : pre) {\n            auto it = cur->next.find(c);\n            if (it == cur->next.end()) return 0;\n            cur = it->second;\n        }\n        return cur->pass;\n    }\n};\n```\n\n---\n\n# 6. Python 版本（更易讀）\n```python\nclass TrieNode:\n    __slots__ = (\"next\", \"pass_cnt\", \"end_cnt\")\n    def __init__(self):\n        self.next = {}        # char -> TrieNode\n        self.pass_cnt = 0\n        self.end_cnt = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        cur = self.root\n        cur.pass_cnt += 1\n        for ch in word:\n            if ch not in cur.next:\n                cur.next[ch] = TrieNode()\n            cur = cur.next[ch]\n            cur.pass_cnt += 1\n        cur.end_cnt += 1\n\n    def search(self, word: str) -> bool:\n        cur = self.root\n        for ch in word:\n            if ch not in cur.next:\n                return False\n            cur = cur.next[ch]\n        return cur.end_cnt > 0\n\n    def startsWith(self, prefix: str) -> bool:\n        cur = self.root\n        for ch in prefix:\n            if ch not in cur.next:\n                return False\n            cur = cur.next[ch]\n        return True\n\n    def countWordsEqualTo(self, word: str) -> int:\n        cur = self.root\n        for ch in word:\n            if ch not in cur.next: return 0\n            cur = cur.next[ch]\n        return cur.end_cnt\n\n    def countWordsStartingWith(self, prefix: str) -> int:\n        cur = self.root\n        for ch in prefix:\n            if ch not in cur.next: return 0\n            cur = cur.next[ch]\n        return cur.pass_cnt\n\n    def erase(self, word: str) -> bool:\n        # 確認存在\n        cur = self.root\n        stack = [cur]\n        for ch in word:\n            if ch not in cur.next: return False\n            cur = cur.next[ch]\n            stack.append(cur)\n        if cur.end_cnt == 0: return False\n\n        # 刪除計數\n        cur.end_cnt -= 1\n        for node in stack:\n            node.pass_cnt -= 1\n\n        # 清理孤兒\n        cur = self.root\n        for ch in word:\n            nxt = cur.next[ch]\n            if nxt.pass_cnt == 0:\n                del cur.next[ch]\n                break\n            cur = nxt\n        return True\n```\n\n---\n\n# 7. 常見坑（初學者必看）\n1. **大小寫／非英文字元**：若限定 a–z，請先轉小寫；否則改用 map 版本。  \n2. **結尾標記**：`search` 要檢查 `end>0`；只到節點不代表是完整單字。  \n3. **重複插入與刪除**：用 `end`、`pass` 維護計數，支援多次插入／刪除。  \n4. **記憶體釋放（C++）**：務必回收無用節點。  \n5. **Unicode**：可改以 codepoint 為單位（python 自然支援；C++ 可考慮 `char32_t`）。  \n6. **效率權衡**：陣列 vs map/unordered_map 視字元集大小選擇。\n\n---\n\n# 8. 進階與變體\n- **壓縮 Trie（Radix/Patricia）**：把單鏈路徑壓成一段字串，節省空間。  \n- **Aho–Corasick**：多模式匹配（敏感詞），在 Trie 上加 fail 指針。  \n- **Bitwise Trie（數位樹）**：按位儲存整數，用於最大 XOR 等題。  \n- **Ternary Search Tree**：以 BST 思想按字元分支，省空間且支持字典序操作。\n\n---\n\n# 9. 典型題目\n- LC 208 Implement Trie (Prefix Tree) — 基礎 CRUD  \n- LC 211 Add and Search Word — 搜尋支援 '.' 萬用字（Trie+回溯）  \n- LC 212 Word Search II — 盤面找字（Trie+DFS）  \n- LC 648 Replace Words — 字典替換  \n- LC 421 Maximum XOR of Two Numbers — Bitwise Trie  \n- LC 1032 Stream of Characters — 逆向 Trie 線上匹配\n\n---\n\n# 10. 小結\n- Trie 以「字元路徑」呈現多字串共享前綴，前綴查詢 `O(L)` 高效直覺。  \n- 初學者先用 a–z 陣列版，熟悉後再擴展到 map 版、多語系、壓縮 Trie 與 Aho–Corasick。\n\n---\n\n# 11. 速查表\n- 插入：走到底、`pass++`、`end++`。  \n- 搜尋：走到底、判 `end>0`。  \n- 前綴：走到 prefix 即成功。  \n- 刪除：`end--`、沿路 `pass--`，必要時刪孤兒。  \n- 複雜度：均攤 `O(L)`；空間 ~ 節點數。\n"
  },
  {
    "id": "190-reverse-bits-bit-ops",
    "title": "Data Structure / Algorithm Concept Note：Bit 操作速查（搭配 LC190 Reverse Bits）",
    "category": "technique",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/techniques/190-reverse-bits-bit-ops.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-12-16",
    "markdownContent": "# Data Structure / Algorithm Concept Note：Bit 操作速查（搭配 LC190 Reverse Bits）\n\n> 這份筆記重點是「看得懂 bit 語法」與「能寫出基本位元處理骨架」，不直接給可提交的完整解答。\n\n---\n\n## 0. Metadata\n- **Concept Name**: Bit Operations（位元運算）\n- **Category**: 基礎語法 / Bit Manipulation Pattern\n- **Tags**: `bitmask`, `shift`, `AND`, `OR`, `XOR`, `uint32_t`, `LC190`\n- **Prerequisites**: 二進位表示法、32-bit（含前導 0）\n- **Familiarity (1–5)**: 1（先從 0 開始也 OK）\n- **Last Updated**: 2025-12-12\n\n---\n\n## 1. Core Concept（What & Why）\n### 直覺理解\n把整數想成 **二進位 bit 串**。位元運算就是對每一個 bit 做規則性的操作（取某一位、設某一位、清某一位、左右搬移等）。\n\n### 常見題型\n- 取最低位 / 取第 k 位\n- 設定位（set bit）/ 清除位（clear bit）\n- 反轉 bit 串（reverse bits）— LC190\n- 位元統計（popcount / count 1s）\n- bitmask 表示集合、子集枚舉\n\n### Complexity 目標\n通常是 **O(位數)**：32 或 64 都可視為常數時間。\n\n---\n\n## 2. Invariants & Properties\n### Core Invariants\n- **Mask（遮罩）**：用 `1<<k` 只影響第 k 位\n- **移位（shift）**：\n  - `>>` 會把低位丟掉（向右移）\n  - `<<` 會在低位補 0（向左移）\n\n### Common Pitfalls\n- **一定要處理滿 32 位**（LC190 需要包含前導 0）\n- **signed vs unsigned 的右移**：\n  - 有些語言/編譯器對「帶符號右移」可能做算術右移（補符號位）\n  - LC190 建議用 `uint32_t` 更穩\n- **運算子優先序**：位元運算常需要括號（尤其混用 `+ - *` 時）\n\n---\n\n## 3. Common Solution Patterns\n\n### Pattern A：取最低位（LSB）+ 逐步右移\n**When to use**：你想從右到左一位一位讀出 bit  \n- **Steps**：\n  1. `bit = n & 1` 取最低位\n  2. `n >>= 1` 丟掉最低位，下一輪讀新的最低位\n\n**Complexity**：每輪 O(1)，共 32/64 輪。\n\n### Pattern B：答案左移騰位 + 塞 bit\n**When to use**：你想「逐步建立」新的 bit 串  \n- **Steps**：\n  1. `ans <<= 1` 騰出一格\n  2. `ans |= bit` 把 bit 塞進最低位\n\n---\n\n## 4. Pseudocode（Language-Agnostic Skeleton）\n```text\nans = 0\nrepeat 32 times:\n    bit = n AND 1\n    ans = (ans SHIFT_LEFT 1) OR bit\n    n = n SHIFT_RIGHT 1\nreturn ans\n```\n\n---\n\n## 5. Syntax Cheat‑Sheet（你最常看到的符號）\n\n### 5.1 `&`（AND）\n**規則**：兩個 bit 都是 1 才是 1  \n**最常見用法**\n- 取最低位：`n & 1`\n- 檢查第 k 位是否為 1：`(n & (1u << k)) != 0`\n- 清除最低位 1：`n & (n - 1)`（常用技巧）\n\n**為什麼取最低位要用 `n & 1` 而不是 `n | 1`？**\n- `n & 1`：看「最低位」本來是 0 或 1 → 結果就是 0 或 1\n- `n | 1`：會把最低位 **強制變成 1** → 不是「取」，是「設」\n\n例：\n- `4 (100) & 1 = 0` ✅（最低位是 0）\n- `4 (100) | 1 = 5 (101)` ❌（被改掉了）\n\n---\n\n### 5.2 `|`（OR）\n**規則**：只要其中一個 bit 是 1 就是 1  \n**用法**\n- 設第 k 位為 1：`n |= (1u << k)`（set bit）\n- 把某個 `bit` 塞進去：`ans |= bit`\n\n---\n\n### 5.3 `^`（XOR）\n**規則**：兩個 bit 不同才是 1  \n**用法**\n- 翻轉第 k 位：`n ^= (1u << k)`\n- 交換 / 差異偵測常見（也常出現在題目）\n\n---\n\n### 5.4 `~`（NOT）\n**規則**：bit 取反（0↔1）  \n**用法**\n- 清除第 k 位：`n &= ~(1u << k)`\n> 注意：`~` 會把所有位都反轉，所以幾乎都會搭配 mask。\n\n---\n\n### 5.5 `<<`（左移）\n**直覺**：整個 bit 串往左搬，右邊補 0  \n**常見**：`1u << k` 產生 mask（第 k 位是 1，其餘 0）\n\n---\n\n### 5.6 `>>`（右移）\n**直覺**：整個 bit 串往右搬，右邊掉出來的位會消失  \n**常見**\n- 逐位讀：`n >>= 1`\n- 取第 k 位：`(n >> k) & 1`\n\n---\n\n### 5.7 `>>=` / `<<=` / `|=` / `&=`（複合指定）\n- `n >>= 1` 等同 `n = n >> 1`\n- `ans <<= 1` 等同 `ans = ans << 1`\n- `ans |= bit` 等同 `ans = ans | bit`\n\n---\n\n## 6. Minimal Working Example（手算一小段）\n假設只看 8-bit（示意用），n = `00010110`  \n我們想反轉成 `01101000`\n\n- 初始：`ans=00000000`\n- 取 bit：`n&1=0` → `ans<<=1` → `ans|=0` → `ans=00000000`，`n>>=1`→`00001011`\n- 下一輪：`n&1=1` → `ans=00000001`，`n=00000101`\n- …（重複固定流程）\n\n**重點**：每輪都在做「讀最低位」＋「答案左移塞入」。\n\n---\n\n## 7. Edge Cases & Tests（LC190 特別重要）\n- `n = 0` → 反轉仍是 0\n- `n = 1` → 反轉後是 `1 << 31`\n- `n` 二進位前面很多 0 → 仍要完整跑 32 次，不然會漏掉前導 0 的反轉\n- 隨機測：\n  - `n = 43261596` → `964176192`（題目範例）\n  - `n = 2147483644` → `1073741822`（題目範例）\n\n---\n\n## 8. Relation to Neighboring Concepts\n- `popcount`（數 1 的個數）與 `n & (n-1)` 常一起出現\n- bitmask 表示集合（子集枚舉 `for mask in [0..2^n)`）\n- 位元分治與查表（lookup table）是常見優化方式\n\n---\n\n## 9. Implementation Skeleton（留給你練習；非可提交完整碼）\n### C++ Skeleton（LC190 方向）\n```cpp\n// Idea: repeat 32 times, take LSB, push into ans.\nuint32_t reverseBits(uint32_t n) {\n    uint32_t ans = 0;\n    // repeat 32:\n    //   bit = n & 1\n    //   ans = (ans << 1) | bit\n    //   n >>= 1\n    return ans;\n}\n```\n\n---\n\n## 10. Common Problems（練習題清單）\n- LeetCode:\n  - [x] 190. Reverse Bits\n  - [ ] 191. Number of 1 Bits\n  - [ ] 268. Missing Number（XOR）\n  - [ ] 136. Single Number（XOR）\n\n---\n\n## 11. Practice Plan（快速熟悉）\n- Day 0：熟記 `& 1`、`(1<<k)`、`(n>>k)&1`\n- Day 2：做 LC191 + 練 set/clear/toggle 第 k 位\n- Day 7：做一題 bitmask 子集枚舉\n\n---\n\n## 12. Personal Notes（你的重點提醒）\n- 「取最低位」是 **讀**：用 `& 1`  \n  「把最低位變 1」是 **寫**：用 `| 1`\n- 看到 `>>` / `<<`：\n  - `>>` 常用來「拿某一位」或「逐位掃描」\n  - `<<` 常用來「做 mask」或「把答案往左推騰位」\n\n---\n\n## 13. References\n- LeetCode 190: Reverse Bits\n- C++ `uint32_t`（避免 signed shift 問題）\n"
  },
  {
    "id": "prefix-suffix-precompute",
    "title": "前綴 / 後綴預計算與應用",
    "category": "technique",
    "topics": [
      "Prefix",
      "Suffix",
      "Precompute",
      "Array"
    ],
    "difficulty": "intermediate",
    "description": "預先計算累積資訊一次 → 回答多次查詢或在 O(1)/O(log n) 內驗證約束條件。",
    "contentPath": "/content/notes/techniques/prefix-suffix-precompute.md",
    "createdAt": "2025-10-05",
    "updatedAt": "2025-10-05",
    "markdownContent": "# 前綴 / 後綴預計算與應用\n\n## 0. 概述\n- **概念名稱**：前綴 / 後綴預計算（總和、最小/最大值、單調性等）\n- **類別**：演算法預處理\n- **標籤**：prefix sum, suffix sum, prefix min/max, inc/dec flags, feasibility checks, difference array, 2D prefix sum, XOR prefix\n- **前置知識**：陣列、基礎數學、時間/空間權衡\n- **熟悉度（1–5）**：3\n- **最後更新**：2025-10-05 (UTC+8)\n\n---\n\n## 1. 核心概念（What & Why）\n**預先計算累積資訊一次 → 回答多次查詢或在 O(1)/O(log n) 內驗證約束條件。**\n- **前綴**在索引 `i` 處總結從開頭到 `i` 的資料（例如：總和/最小值/最大值/遞增驗證）。\n- **後綴**在索引 `i` 處總結從 `i` 到結尾的資料。\n- 將它們結合以快速評估分割/切割、範圍和可行性。\n\n**何時使用**\n- 多次**範圍**查詢。\n- 需要在**每個切點檢查可行性**（例如：前綴嚴格遞增**且**後綴嚴格遞減）。\n- 將昂貴的每次查詢成本 → 在 O(n) 預處理後變成便宜的常數時間。\n\n---\n\n## 2. 標準構造方式\n\n### 2.1 前綴和（1D）\n- `pref[i] = a[0] + ... + a[i]`（使用 64 位元以避免溢位）\n- 範圍和 `[l..r] = pref[r] − (l>0 ? pref[l‑1] : 0)`\n\n**C++ 程式碼片段**\n```cpp\nvector<long long> pref(n);\npref[0] = a[0];\nfor (int i = 1; i < n; ++i) pref[i] = pref[i-1] + a[i];\n\nauto range_sum = [&](int l, int r) -> long long {\n    return pref[r] - (l ? pref[l-1] : 0LL);\n};\n```\n\n### 2.2 後綴和\n```cpp\nvector<long long> suff(n);\nsuff[n-1] = a[n-1];\nfor (int i = n-2; i >= 0; --i) suff[i] = suff[i+1] + a[i];\n```\n\n### 2.3 前綴最小/最大 & 後綴最小/最大\n- `pmin[i] = min(a[0..i])`, `pmax[i] = max(a[0..i])`\n- `smin[i] = min(a[i..n-1])`, `smax[i] = max(a[i..n-1])`\n\n### 2.4 單調性標記（遞增/遞減可行性）\n- `inc[i] = inc[i-1] && (a[i-1] < a[i])`（嚴格遞增前綴）\n- `dec[i] = dec[i+1] && (a[i] > a[i+1])`（嚴格遞減後綴）\n\n### 2.5 前綴 XOR / AND / OR / GCD\n- XOR: `px[i] = px[i-1] ^ a[i]` → 在 O(1) 內得到範圍 XOR。\n- GCD: `pg[i] = gcd(pg[i-1], a[i])`, `sg[i] = gcd(a[i], sg[i+1])` → 透過 `gcd(pg[l-1], sg[r+1])` 得到範圍 gcd。\n\n### 2.6 差分陣列（範圍加法 O(1)，最後用前綴處理）\n- 在 `[l..r]` 加 `+v`: `diff[l] += v; diff[r+1] -= v;`\n- 還原: `arr = prefix(diff)`。\n\n### 2.7 2D 前綴和（積分影像）\n- `P[i][j] = sum of A[0..i][0..j]`\n- 矩形和 `(r1..r2, c1..c2)` 透過容斥原理計算。\n\n---\n\n## 3. 典型應用\n\n1. **範圍和 / XOR 查詢**：當只需要總和/XOR 時，可作為 RMQ 的替代方案。\n2. **平衡 / 分割問題**：在約束條件下最小化 `|sum(left) − sum(right)|`。\n3. **切點可行性**：例如 `inc[i] && dec[i+1]` 確保左邊嚴格遞增且右邊嚴格遞減。\n4. **排除一個元素的 GCD**：`除了 a[k] 的所有元素的 gcd = gcd(pg[k-1], sg[k+1])`。\n5. **閾值 / 邊界測試**：前綴最小值 vs 當前值，或後綴最大值 vs 當前值。\n6. **差分陣列**：多次範圍更新 + 一次最終處理。\n7. **2D 範圍和**：在 O(1) 內進行子矩陣查詢。\n\n---\n\n## 4. 模式 —「枚舉切點並預計算可行性」\n**目標**：快速檢查在 `i` 之後切割是否有效，然後評估指標（例如：總和差異）。\n\n**步驟**\n1. 建立 `inc[0..i]` 和 `dec[i+1..]` 標記。\n2. 建立 `pref` 以在 O(1) 內得到左/右總和。\n3. 迴圈所有 `i` (0..n‑2)，若可行：計算指標並取最小/最大值。\n\n**虛擬碼**\n```text\nbuild inc[], dec[], pref[]\nbest = +INF\nfor i in 0..n-2:\n    if inc[i] && dec[i+1]:\n        left  = pref[i]\n        right = pref[n-1] - pref[i]\n        best = min(best, |left - right|)\nreturn best or -1 if no feasible\n```\n\n---\n\n## 5. 邊界情況與陷阱\n- **嚴格 vs 非嚴格**：正確使用 `<` / `>` vs `<=` / `>=`。\n- **單一元素子陣列**：通常計為嚴格單調；確認題目說明。\n- **溢位**：對總和使用 `long long`；注意 2D 總和。\n- **索引**：`pref[r] − pref[l-1]` 模式；保護 `l=0`。\n- **空邊**：枚舉切點時，確保兩邊都非空（`i ≤ n‑2`）。\n- **2D 邊界**：容斥原理的 off-by-one。\n- **差分陣列最終處理**：別忘了最後的前綴處理。\n\n---\n\n## 6. 微練習\n1. 為陣列建立 `inc[]` / `dec[]` 並計算有多少可行的切點存在。\n2. 給定查詢 `[l,r]`，用 `pref[]` 和 `suff[]` 回答 `sum(l,r)`（練習兩者）。\n3. 用 1D 差分陣列實作「範圍加法更新 + 點查詢」。\n4. 實作 2D 前綴和並查詢矩形總和。\n5. 用前綴/後綴 GCD 陣列實作排除一個元素的 GCD。\n\n---\n\n## 7. C++ 最小骨架\n\n**前綴/後綴和 & 可行性**\n```cpp\nvector<long long> pref(n);\npref[0] = a[0];\nfor (int i = 1; i < n; ++i) pref[i] = pref[i-1] + a[i];\n\nvector<char> inc(n, 0), dec(n, 0);\ninc[0] = 1;\nfor (int i = 1; i < n; ++i) inc[i] = inc[i-1] && (a[i-1] < a[i]);\ndec[n-1] = 1;\nfor (int i = n-2; i >= 0; --i) dec[i] = dec[i+1] && (a[i] > a[i+1]);\n```\n\n**差分陣列**\n```cpp\nvector<long long> diff(n+1);\nauto add = [&](int l, int r, long long v){\n    diff[l] += v;\n    if (r+1 < (int)diff.size()) diff[r+1] -= v;\n};\nvector<long long> arr(n);\nlong long run = 0;\nfor (int i = 0; i < n; ++i) { run += diff[i]; arr[i] = run; }\n```\n\n**2D 前綴（簡要）**\n```cpp\nvector<vector<long long>> P(n+1, vector<long long>(m+1));\nfor (int i = 1; i <= n; ++i)\n  for (int j = 1; j <= m; ++j)\n    P[i][j] = A[i][j] + P[i-1][j] + P[i][j-1] - P[i-1][j-1];\n\nauto rect = [&](int r1,int c1,int r2,int c2){\n  return P[r2][c2]-P[r1-1][c2]-P[r2][c1-1]+P[r1-1][c1-1];\n};\n```\n\n---\n\n## 8. 相關概念\n- 滑動視窗（當範圍連續且移動 1 時）。\n- Fenwick Tree / Segment Tree（帶 log 因子的範圍查詢/更新）。\n- 單調堆疊/佇列（不同的「單調」但常與前綴資訊配對）。\n- 稀疏表（等冪範圍查詢，如 min/max）。\n\n---\n\n## 9. 編碼前快速檢查清單\n- 決定嚴格 vs 非嚴格。\n- 如果值可能很大或數量很多，選擇 64 位元總和。\n- 確認切點範圍（確保兩邊非空）。\n- 僅預計算所需內容（總和？最小值？標記？gcd？）。\n- 為 `n=1/2`、相等元素、負數、大值加入測試。\n\n---\n\n## 10. 個人筆記\n- 對於有約束條件的分割陣列問題，**inc/dec + 前綴和**是強大的 O(n) 模式。\n- 當有**多次範圍更新**但只有一次最終讀取時，差分陣列很好用。\n- 2D 前綴和通常是無更新的子矩陣查詢的最快路徑。\n"
  }
];

export function getNotesByCategory(category: keyof typeof NOTE_CATEGORIES): Note[] {
  return NOTES.filter(note => note.category === category);
}

export function getNotesByTopic(topic: string): Note[] {
  return NOTES.filter(note => 
    note.topics.some(t => t.toLowerCase() === topic.toLowerCase())
  );
}

export function getNoteById(id: string): Note | undefined {
  return NOTES.find(note => note.id === id);
}
